ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 1


   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"UART.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.global	UART_initVar
  18              		.bss
  19              		.type	UART_initVar, %object
  20              		.size	UART_initVar, 1
  21              	UART_initVar:
  22 0000 00       		.space	1
  23              		.section	.text.UART_Start,"ax",%progbits
  24              		.align	2
  25              		.global	UART_Start
  26              		.code	16
  27              		.thumb_func
  28              		.type	UART_Start, %function
  29              	UART_Start:
  30              	.LFB1:
  31              		.file 1 ".\\Generated_Source\\PSoC4\\UART.c"
   1:.\Generated_Source\PSoC4/UART.c **** /*******************************************************************************
   2:.\Generated_Source\PSoC4/UART.c **** * File Name: UART.c
   3:.\Generated_Source\PSoC4/UART.c **** * Version 2.50
   4:.\Generated_Source\PSoC4/UART.c **** *
   5:.\Generated_Source\PSoC4/UART.c **** * Description:
   6:.\Generated_Source\PSoC4/UART.c **** *  This file provides all API functionality of the UART component
   7:.\Generated_Source\PSoC4/UART.c **** *
   8:.\Generated_Source\PSoC4/UART.c **** * Note:
   9:.\Generated_Source\PSoC4/UART.c **** *
  10:.\Generated_Source\PSoC4/UART.c **** ********************************************************************************
  11:.\Generated_Source\PSoC4/UART.c **** * Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
  12:.\Generated_Source\PSoC4/UART.c **** * You may use this file only in accordance with the license, terms, conditions,
  13:.\Generated_Source\PSoC4/UART.c **** * disclaimers, and limitations in the end user license agreement accompanying
  14:.\Generated_Source\PSoC4/UART.c **** * the software package with which this file was provided.
  15:.\Generated_Source\PSoC4/UART.c **** *******************************************************************************/
  16:.\Generated_Source\PSoC4/UART.c **** 
  17:.\Generated_Source\PSoC4/UART.c **** #include "UART.h"
  18:.\Generated_Source\PSoC4/UART.c **** #if (UART_INTERNAL_CLOCK_USED)
  19:.\Generated_Source\PSoC4/UART.c ****     #include "UART_IntClock.h"
  20:.\Generated_Source\PSoC4/UART.c **** #endif /* End UART_INTERNAL_CLOCK_USED */
  21:.\Generated_Source\PSoC4/UART.c **** 
  22:.\Generated_Source\PSoC4/UART.c **** 
  23:.\Generated_Source\PSoC4/UART.c **** /***************************************
  24:.\Generated_Source\PSoC4/UART.c **** * Global data allocation
  25:.\Generated_Source\PSoC4/UART.c **** ***************************************/
  26:.\Generated_Source\PSoC4/UART.c **** 
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 2


  27:.\Generated_Source\PSoC4/UART.c **** uint8 UART_initVar = 0u;
  28:.\Generated_Source\PSoC4/UART.c **** 
  29:.\Generated_Source\PSoC4/UART.c **** #if (UART_TX_INTERRUPT_ENABLED && UART_TX_ENABLED)
  30:.\Generated_Source\PSoC4/UART.c ****     volatile uint8 UART_txBuffer[UART_TX_BUFFER_SIZE];
  31:.\Generated_Source\PSoC4/UART.c ****     volatile uint8 UART_txBufferRead = 0u;
  32:.\Generated_Source\PSoC4/UART.c ****     uint8 UART_txBufferWrite = 0u;
  33:.\Generated_Source\PSoC4/UART.c **** #endif /* (UART_TX_INTERRUPT_ENABLED && UART_TX_ENABLED) */
  34:.\Generated_Source\PSoC4/UART.c **** 
  35:.\Generated_Source\PSoC4/UART.c **** #if (UART_RX_INTERRUPT_ENABLED && (UART_RX_ENABLED || UART_HD_ENABLED))
  36:.\Generated_Source\PSoC4/UART.c ****     uint8 UART_errorStatus = 0u;
  37:.\Generated_Source\PSoC4/UART.c ****     volatile uint8 UART_rxBuffer[UART_RX_BUFFER_SIZE];
  38:.\Generated_Source\PSoC4/UART.c ****     volatile uint8 UART_rxBufferRead  = 0u;
  39:.\Generated_Source\PSoC4/UART.c ****     volatile uint8 UART_rxBufferWrite = 0u;
  40:.\Generated_Source\PSoC4/UART.c ****     volatile uint8 UART_rxBufferLoopDetect = 0u;
  41:.\Generated_Source\PSoC4/UART.c ****     volatile uint8 UART_rxBufferOverflow   = 0u;
  42:.\Generated_Source\PSoC4/UART.c ****     #if (UART_RXHW_ADDRESS_ENABLED)
  43:.\Generated_Source\PSoC4/UART.c ****         volatile uint8 UART_rxAddressMode = UART_RX_ADDRESS_MODE;
  44:.\Generated_Source\PSoC4/UART.c ****         volatile uint8 UART_rxAddressDetected = 0u;
  45:.\Generated_Source\PSoC4/UART.c ****     #endif /* (UART_RXHW_ADDRESS_ENABLED) */
  46:.\Generated_Source\PSoC4/UART.c **** #endif /* (UART_RX_INTERRUPT_ENABLED && (UART_RX_ENABLED || UART_HD_ENABLED)) */
  47:.\Generated_Source\PSoC4/UART.c **** 
  48:.\Generated_Source\PSoC4/UART.c **** 
  49:.\Generated_Source\PSoC4/UART.c **** /*******************************************************************************
  50:.\Generated_Source\PSoC4/UART.c **** * Function Name: UART_Start
  51:.\Generated_Source\PSoC4/UART.c **** ********************************************************************************
  52:.\Generated_Source\PSoC4/UART.c **** *
  53:.\Generated_Source\PSoC4/UART.c **** * Summary:
  54:.\Generated_Source\PSoC4/UART.c **** *  This is the preferred method to begin component operation.
  55:.\Generated_Source\PSoC4/UART.c **** *  UART_Start() sets the initVar variable, calls the
  56:.\Generated_Source\PSoC4/UART.c **** *  UART_Init() function, and then calls the
  57:.\Generated_Source\PSoC4/UART.c **** *  UART_Enable() function.
  58:.\Generated_Source\PSoC4/UART.c **** *
  59:.\Generated_Source\PSoC4/UART.c **** * Parameters:
  60:.\Generated_Source\PSoC4/UART.c **** *  None.
  61:.\Generated_Source\PSoC4/UART.c **** *
  62:.\Generated_Source\PSoC4/UART.c **** * Return:
  63:.\Generated_Source\PSoC4/UART.c **** *  None.
  64:.\Generated_Source\PSoC4/UART.c **** *
  65:.\Generated_Source\PSoC4/UART.c **** * Global variables:
  66:.\Generated_Source\PSoC4/UART.c **** *  The UART_intiVar variable is used to indicate initial
  67:.\Generated_Source\PSoC4/UART.c **** *  configuration of this component. The variable is initialized to zero (0u)
  68:.\Generated_Source\PSoC4/UART.c **** *  and set to one (1u) the first time UART_Start() is called. This
  69:.\Generated_Source\PSoC4/UART.c **** *  allows for component initialization without re-initialization in all
  70:.\Generated_Source\PSoC4/UART.c **** *  subsequent calls to the UART_Start() routine.
  71:.\Generated_Source\PSoC4/UART.c **** *
  72:.\Generated_Source\PSoC4/UART.c **** * Reentrant:
  73:.\Generated_Source\PSoC4/UART.c **** *  No.
  74:.\Generated_Source\PSoC4/UART.c **** *
  75:.\Generated_Source\PSoC4/UART.c **** *******************************************************************************/
  76:.\Generated_Source\PSoC4/UART.c **** void UART_Start(void) 
  77:.\Generated_Source\PSoC4/UART.c **** {
  32              		.loc 1 77 0
  33              		.cfi_startproc
  34 0000 80B5     		push	{r7, lr}
  35              		.cfi_def_cfa_offset 8
  36              		.cfi_offset 7, -8
  37              		.cfi_offset 14, -4
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 3


  38 0002 00AF     		add	r7, sp, #0
  39              		.cfi_def_cfa_register 7
  78:.\Generated_Source\PSoC4/UART.c ****     /* If not initialized then initialize all required hardware and software */
  79:.\Generated_Source\PSoC4/UART.c ****     if(UART_initVar == 0u)
  40              		.loc 1 79 0
  41 0004 064B     		ldr	r3, .L3
  42 0006 1B78     		ldrb	r3, [r3]
  43 0008 002B     		cmp	r3, #0
  44 000a 04D1     		bne	.L2
  80:.\Generated_Source\PSoC4/UART.c ****     {
  81:.\Generated_Source\PSoC4/UART.c ****         UART_Init();
  45              		.loc 1 81 0
  46 000c FFF7FEFF 		bl	UART_Init
  82:.\Generated_Source\PSoC4/UART.c ****         UART_initVar = 1u;
  47              		.loc 1 82 0
  48 0010 034B     		ldr	r3, .L3
  49 0012 0122     		mov	r2, #1
  50 0014 1A70     		strb	r2, [r3]
  51              	.L2:
  83:.\Generated_Source\PSoC4/UART.c ****     }
  84:.\Generated_Source\PSoC4/UART.c **** 
  85:.\Generated_Source\PSoC4/UART.c ****     UART_Enable();
  52              		.loc 1 85 0
  53 0016 FFF7FEFF 		bl	UART_Enable
  86:.\Generated_Source\PSoC4/UART.c **** }
  54              		.loc 1 86 0
  55 001a BD46     		mov	sp, r7
  56              		@ sp needed
  57 001c 80BD     		pop	{r7, pc}
  58              	.L4:
  59 001e C046     		.align	2
  60              	.L3:
  61 0020 00000000 		.word	UART_initVar
  62              		.cfi_endproc
  63              	.LFE1:
  64              		.size	UART_Start, .-UART_Start
  65              		.section	.text.UART_Init,"ax",%progbits
  66              		.align	2
  67              		.global	UART_Init
  68              		.code	16
  69              		.thumb_func
  70              		.type	UART_Init, %function
  71              	UART_Init:
  72              	.LFB2:
  87:.\Generated_Source\PSoC4/UART.c **** 
  88:.\Generated_Source\PSoC4/UART.c **** 
  89:.\Generated_Source\PSoC4/UART.c **** /*******************************************************************************
  90:.\Generated_Source\PSoC4/UART.c **** * Function Name: UART_Init
  91:.\Generated_Source\PSoC4/UART.c **** ********************************************************************************
  92:.\Generated_Source\PSoC4/UART.c **** *
  93:.\Generated_Source\PSoC4/UART.c **** * Summary:
  94:.\Generated_Source\PSoC4/UART.c **** *  Initializes or restores the component according to the customizer Configure
  95:.\Generated_Source\PSoC4/UART.c **** *  dialog settings. It is not necessary to call UART_Init() because
  96:.\Generated_Source\PSoC4/UART.c **** *  the UART_Start() API calls this function and is the preferred
  97:.\Generated_Source\PSoC4/UART.c **** *  method to begin component operation.
  98:.\Generated_Source\PSoC4/UART.c **** *
  99:.\Generated_Source\PSoC4/UART.c **** * Parameters:
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 4


 100:.\Generated_Source\PSoC4/UART.c **** *  None.
 101:.\Generated_Source\PSoC4/UART.c **** *
 102:.\Generated_Source\PSoC4/UART.c **** * Return:
 103:.\Generated_Source\PSoC4/UART.c **** *  None.
 104:.\Generated_Source\PSoC4/UART.c **** *
 105:.\Generated_Source\PSoC4/UART.c **** *******************************************************************************/
 106:.\Generated_Source\PSoC4/UART.c **** void UART_Init(void) 
 107:.\Generated_Source\PSoC4/UART.c **** {
  73              		.loc 1 107 0
  74              		.cfi_startproc
  75 0000 80B5     		push	{r7, lr}
  76              		.cfi_def_cfa_offset 8
  77              		.cfi_offset 7, -8
  78              		.cfi_offset 14, -4
  79 0002 00AF     		add	r7, sp, #0
  80              		.cfi_def_cfa_register 7
 108:.\Generated_Source\PSoC4/UART.c ****     #if(UART_RX_ENABLED || UART_HD_ENABLED)
 109:.\Generated_Source\PSoC4/UART.c **** 
 110:.\Generated_Source\PSoC4/UART.c ****         #if (UART_RX_INTERRUPT_ENABLED)
 111:.\Generated_Source\PSoC4/UART.c ****             /* Set RX interrupt vector and priority */
 112:.\Generated_Source\PSoC4/UART.c ****             (void) CyIntSetVector(UART_RX_VECT_NUM, &UART_RXISR);
 113:.\Generated_Source\PSoC4/UART.c ****             CyIntSetPriority(UART_RX_VECT_NUM, UART_RX_PRIOR_NUM);
 114:.\Generated_Source\PSoC4/UART.c ****             UART_errorStatus = 0u;
 115:.\Generated_Source\PSoC4/UART.c ****         #endif /* (UART_RX_INTERRUPT_ENABLED) */
 116:.\Generated_Source\PSoC4/UART.c **** 
 117:.\Generated_Source\PSoC4/UART.c ****         #if (UART_RXHW_ADDRESS_ENABLED)
 118:.\Generated_Source\PSoC4/UART.c ****             UART_SetRxAddressMode(UART_RX_ADDRESS_MODE);
 119:.\Generated_Source\PSoC4/UART.c ****             UART_SetRxAddress1(UART_RX_HW_ADDRESS1);
 120:.\Generated_Source\PSoC4/UART.c ****             UART_SetRxAddress2(UART_RX_HW_ADDRESS2);
 121:.\Generated_Source\PSoC4/UART.c ****         #endif /* End UART_RXHW_ADDRESS_ENABLED */
 122:.\Generated_Source\PSoC4/UART.c **** 
 123:.\Generated_Source\PSoC4/UART.c ****         /* Init Count7 period */
 124:.\Generated_Source\PSoC4/UART.c ****         UART_RXBITCTR_PERIOD_REG = UART_RXBITCTR_INIT;
  81              		.loc 1 124 0
  82 0004 084B     		ldr	r3, .L6
  83 0006 7222     		mov	r2, #114
  84 0008 1A70     		strb	r2, [r3]
 125:.\Generated_Source\PSoC4/UART.c ****         /* Configure the Initial RX interrupt mask */
 126:.\Generated_Source\PSoC4/UART.c ****         UART_RXSTATUS_MASK_REG  = UART_INIT_RX_INTERRUPTS_MASK;
  85              		.loc 1 126 0
  86 000a 084B     		ldr	r3, .L6+4
  87 000c 2022     		mov	r2, #32
  88 000e 1A70     		strb	r2, [r3]
 127:.\Generated_Source\PSoC4/UART.c ****     #endif /* End UART_RX_ENABLED || UART_HD_ENABLED*/
 128:.\Generated_Source\PSoC4/UART.c **** 
 129:.\Generated_Source\PSoC4/UART.c ****     #if(UART_TX_ENABLED)
 130:.\Generated_Source\PSoC4/UART.c ****         #if (UART_TX_INTERRUPT_ENABLED)
 131:.\Generated_Source\PSoC4/UART.c ****             /* Set TX interrupt vector and priority */
 132:.\Generated_Source\PSoC4/UART.c ****             (void) CyIntSetVector(UART_TX_VECT_NUM, &UART_TXISR);
 133:.\Generated_Source\PSoC4/UART.c ****             CyIntSetPriority(UART_TX_VECT_NUM, UART_TX_PRIOR_NUM);
 134:.\Generated_Source\PSoC4/UART.c ****         #endif /* (UART_TX_INTERRUPT_ENABLED) */
 135:.\Generated_Source\PSoC4/UART.c **** 
 136:.\Generated_Source\PSoC4/UART.c ****         /* Write Counter Value for TX Bit Clk Generator*/
 137:.\Generated_Source\PSoC4/UART.c ****         #if (UART_TXCLKGEN_DP)
 138:.\Generated_Source\PSoC4/UART.c ****             UART_TXBITCLKGEN_CTR_REG = UART_BIT_CENTER;
  89              		.loc 1 138 0
  90 0010 074B     		ldr	r3, .L6+8
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 5


  91 0012 0622     		mov	r2, #6
  92 0014 1A70     		strb	r2, [r3]
 139:.\Generated_Source\PSoC4/UART.c ****             UART_TXBITCLKTX_COMPLETE_REG = ((UART_NUMBER_OF_DATA_BITS +
  93              		.loc 1 139 0
  94 0016 074B     		ldr	r3, .L6+12
  95 0018 4722     		mov	r2, #71
  96 001a 1A70     		strb	r2, [r3]
 140:.\Generated_Source\PSoC4/UART.c ****                         UART_NUMBER_OF_START_BIT) * UART_OVER_SAMPLE_COUNT) - 1u;
 141:.\Generated_Source\PSoC4/UART.c ****         #else
 142:.\Generated_Source\PSoC4/UART.c ****             UART_TXBITCTR_PERIOD_REG = ((UART_NUMBER_OF_DATA_BITS +
 143:.\Generated_Source\PSoC4/UART.c ****                         UART_NUMBER_OF_START_BIT) * UART_OVER_SAMPLE_8) - 1u;
 144:.\Generated_Source\PSoC4/UART.c ****         #endif /* End UART_TXCLKGEN_DP */
 145:.\Generated_Source\PSoC4/UART.c **** 
 146:.\Generated_Source\PSoC4/UART.c ****         /* Configure the Initial TX interrupt mask */
 147:.\Generated_Source\PSoC4/UART.c ****         #if (UART_TX_INTERRUPT_ENABLED)
 148:.\Generated_Source\PSoC4/UART.c ****             UART_TXSTATUS_MASK_REG = UART_TX_STS_FIFO_EMPTY;
 149:.\Generated_Source\PSoC4/UART.c ****         #else
 150:.\Generated_Source\PSoC4/UART.c ****             UART_TXSTATUS_MASK_REG = UART_INIT_TX_INTERRUPTS_MASK;
  97              		.loc 1 150 0
  98 001c 064B     		ldr	r3, .L6+16
  99 001e 0022     		mov	r2, #0
 100 0020 1A70     		strb	r2, [r3]
 151:.\Generated_Source\PSoC4/UART.c ****         #endif /*End UART_TX_INTERRUPT_ENABLED*/
 152:.\Generated_Source\PSoC4/UART.c **** 
 153:.\Generated_Source\PSoC4/UART.c ****     #endif /* End UART_TX_ENABLED */
 154:.\Generated_Source\PSoC4/UART.c **** 
 155:.\Generated_Source\PSoC4/UART.c ****     #if(UART_PARITY_TYPE_SW)  /* Write Parity to Control Register */
 156:.\Generated_Source\PSoC4/UART.c ****         UART_WriteControlRegister( \
 157:.\Generated_Source\PSoC4/UART.c ****             (UART_ReadControlRegister() & (uint8)~UART_CTRL_PARITY_TYPE_MASK) | \
 158:.\Generated_Source\PSoC4/UART.c ****             (uint8)(UART_PARITY_TYPE << UART_CTRL_PARITY_TYPE0_SHIFT) );
 159:.\Generated_Source\PSoC4/UART.c ****     #endif /* End UART_PARITY_TYPE_SW */
 160:.\Generated_Source\PSoC4/UART.c **** }
 101              		.loc 1 160 0
 102 0022 BD46     		mov	sp, r7
 103              		@ sp needed
 104 0024 80BD     		pop	{r7, pc}
 105              	.L7:
 106 0026 C046     		.align	2
 107              	.L6:
 108 0028 81000F40 		.word	1074724993
 109 002c 80000F40 		.word	1074724992
 110 0030 23000F40 		.word	1074724899
 111 0034 33000F40 		.word	1074724915
 112 0038 82000F40 		.word	1074724994
 113              		.cfi_endproc
 114              	.LFE2:
 115              		.size	UART_Init, .-UART_Init
 116              		.section	.text.UART_Enable,"ax",%progbits
 117              		.align	2
 118              		.global	UART_Enable
 119              		.code	16
 120              		.thumb_func
 121              		.type	UART_Enable, %function
 122              	UART_Enable:
 123              	.LFB3:
 161:.\Generated_Source\PSoC4/UART.c **** 
 162:.\Generated_Source\PSoC4/UART.c **** 
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 6


 163:.\Generated_Source\PSoC4/UART.c **** /*******************************************************************************
 164:.\Generated_Source\PSoC4/UART.c **** * Function Name: UART_Enable
 165:.\Generated_Source\PSoC4/UART.c **** ********************************************************************************
 166:.\Generated_Source\PSoC4/UART.c **** *
 167:.\Generated_Source\PSoC4/UART.c **** * Summary:
 168:.\Generated_Source\PSoC4/UART.c **** *  Activates the hardware and begins component operation. It is not necessary
 169:.\Generated_Source\PSoC4/UART.c **** *  to call UART_Enable() because the UART_Start() API
 170:.\Generated_Source\PSoC4/UART.c **** *  calls this function, which is the preferred method to begin component
 171:.\Generated_Source\PSoC4/UART.c **** *  operation.
 172:.\Generated_Source\PSoC4/UART.c **** 
 173:.\Generated_Source\PSoC4/UART.c **** * Parameters:
 174:.\Generated_Source\PSoC4/UART.c **** *  None.
 175:.\Generated_Source\PSoC4/UART.c **** *
 176:.\Generated_Source\PSoC4/UART.c **** * Return:
 177:.\Generated_Source\PSoC4/UART.c **** *  None.
 178:.\Generated_Source\PSoC4/UART.c **** *
 179:.\Generated_Source\PSoC4/UART.c **** * Global Variables:
 180:.\Generated_Source\PSoC4/UART.c **** *  UART_rxAddressDetected - set to initial state (0).
 181:.\Generated_Source\PSoC4/UART.c **** *
 182:.\Generated_Source\PSoC4/UART.c **** *******************************************************************************/
 183:.\Generated_Source\PSoC4/UART.c **** void UART_Enable(void) 
 184:.\Generated_Source\PSoC4/UART.c **** {
 124              		.loc 1 184 0
 125              		.cfi_startproc
 126 0000 90B5     		push	{r4, r7, lr}
 127              		.cfi_def_cfa_offset 12
 128              		.cfi_offset 4, -12
 129              		.cfi_offset 7, -8
 130              		.cfi_offset 14, -4
 131 0002 83B0     		sub	sp, sp, #12
 132              		.cfi_def_cfa_offset 24
 133 0004 00AF     		add	r7, sp, #0
 134              		.cfi_def_cfa_register 7
 185:.\Generated_Source\PSoC4/UART.c ****     uint8 enableInterrupts;
 186:.\Generated_Source\PSoC4/UART.c ****     enableInterrupts = CyEnterCriticalSection();
 135              		.loc 1 186 0
 136 0006 FC1D     		add	r4, r7, #7
 137 0008 FFF7FEFF 		bl	CyEnterCriticalSection
 138 000c 031C     		mov	r3, r0
 139 000e 2370     		strb	r3, [r4]
 187:.\Generated_Source\PSoC4/UART.c **** 
 188:.\Generated_Source\PSoC4/UART.c ****     #if (UART_RX_ENABLED || UART_HD_ENABLED)
 189:.\Generated_Source\PSoC4/UART.c ****         /* RX Counter (Count7) Enable */
 190:.\Generated_Source\PSoC4/UART.c ****         UART_RXBITCTR_CONTROL_REG |= UART_CNTR_ENABLE;
 140              		.loc 1 190 0
 141 0010 114B     		ldr	r3, .L9
 142 0012 114A     		ldr	r2, .L9
 143 0014 1278     		ldrb	r2, [r2]
 144 0016 D2B2     		uxtb	r2, r2
 145 0018 2021     		mov	r1, #32
 146 001a 0A43     		orr	r2, r1
 147 001c D2B2     		uxtb	r2, r2
 148 001e 1A70     		strb	r2, [r3]
 191:.\Generated_Source\PSoC4/UART.c **** 
 192:.\Generated_Source\PSoC4/UART.c ****         /* Enable the RX Interrupt */
 193:.\Generated_Source\PSoC4/UART.c ****         UART_RXSTATUS_ACTL_REG  |= UART_INT_ENABLE;
 149              		.loc 1 193 0
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 7


 150 0020 0E4B     		ldr	r3, .L9+4
 151 0022 0E4A     		ldr	r2, .L9+4
 152 0024 1278     		ldrb	r2, [r2]
 153 0026 D2B2     		uxtb	r2, r2
 154 0028 1021     		mov	r1, #16
 155 002a 0A43     		orr	r2, r1
 156 002c D2B2     		uxtb	r2, r2
 157 002e 1A70     		strb	r2, [r3]
 194:.\Generated_Source\PSoC4/UART.c **** 
 195:.\Generated_Source\PSoC4/UART.c ****         #if (UART_RX_INTERRUPT_ENABLED)
 196:.\Generated_Source\PSoC4/UART.c ****             UART_EnableRxInt();
 197:.\Generated_Source\PSoC4/UART.c **** 
 198:.\Generated_Source\PSoC4/UART.c ****             #if (UART_RXHW_ADDRESS_ENABLED)
 199:.\Generated_Source\PSoC4/UART.c ****                 UART_rxAddressDetected = 0u;
 200:.\Generated_Source\PSoC4/UART.c ****             #endif /* (UART_RXHW_ADDRESS_ENABLED) */
 201:.\Generated_Source\PSoC4/UART.c ****         #endif /* (UART_RX_INTERRUPT_ENABLED) */
 202:.\Generated_Source\PSoC4/UART.c ****     #endif /* (UART_RX_ENABLED || UART_HD_ENABLED) */
 203:.\Generated_Source\PSoC4/UART.c **** 
 204:.\Generated_Source\PSoC4/UART.c ****     #if(UART_TX_ENABLED)
 205:.\Generated_Source\PSoC4/UART.c ****         /* TX Counter (DP/Count7) Enable */
 206:.\Generated_Source\PSoC4/UART.c ****         #if(!UART_TXCLKGEN_DP)
 207:.\Generated_Source\PSoC4/UART.c ****             UART_TXBITCTR_CONTROL_REG |= UART_CNTR_ENABLE;
 208:.\Generated_Source\PSoC4/UART.c ****         #endif /* End UART_TXCLKGEN_DP */
 209:.\Generated_Source\PSoC4/UART.c **** 
 210:.\Generated_Source\PSoC4/UART.c ****         /* Enable the TX Interrupt */
 211:.\Generated_Source\PSoC4/UART.c ****         UART_TXSTATUS_ACTL_REG |= UART_INT_ENABLE;
 158              		.loc 1 211 0
 159 0030 0B4B     		ldr	r3, .L9+8
 160 0032 0B4A     		ldr	r2, .L9+8
 161 0034 1278     		ldrb	r2, [r2]
 162 0036 D2B2     		uxtb	r2, r2
 163 0038 1021     		mov	r1, #16
 164 003a 0A43     		orr	r2, r1
 165 003c D2B2     		uxtb	r2, r2
 166 003e 1A70     		strb	r2, [r3]
 212:.\Generated_Source\PSoC4/UART.c ****         #if (UART_TX_INTERRUPT_ENABLED)
 213:.\Generated_Source\PSoC4/UART.c ****             UART_ClearPendingTxInt(); /* Clear history of TX_NOT_EMPTY */
 214:.\Generated_Source\PSoC4/UART.c ****             UART_EnableTxInt();
 215:.\Generated_Source\PSoC4/UART.c ****         #endif /* (UART_TX_INTERRUPT_ENABLED) */
 216:.\Generated_Source\PSoC4/UART.c ****      #endif /* (UART_TX_INTERRUPT_ENABLED) */
 217:.\Generated_Source\PSoC4/UART.c **** 
 218:.\Generated_Source\PSoC4/UART.c ****     #if (UART_INTERNAL_CLOCK_USED)
 219:.\Generated_Source\PSoC4/UART.c ****         UART_IntClock_Start();  /* Enable the clock */
 167              		.loc 1 219 0
 168 0040 FF20     		mov	r0, #255
 169 0042 FFF7FEFF 		bl	UART_IntClock_StartEx
 220:.\Generated_Source\PSoC4/UART.c ****     #endif /* (UART_INTERNAL_CLOCK_USED) */
 221:.\Generated_Source\PSoC4/UART.c **** 
 222:.\Generated_Source\PSoC4/UART.c ****     CyExitCriticalSection(enableInterrupts);
 170              		.loc 1 222 0
 171 0046 FB1D     		add	r3, r7, #7
 172 0048 1B78     		ldrb	r3, [r3]
 173 004a 181C     		mov	r0, r3
 174 004c FFF7FEFF 		bl	CyExitCriticalSection
 223:.\Generated_Source\PSoC4/UART.c **** }
 175              		.loc 1 223 0
 176 0050 BD46     		mov	sp, r7
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 8


 177 0052 03B0     		add	sp, sp, #12
 178              		@ sp needed
 179 0054 90BD     		pop	{r4, r7, pc}
 180              	.L10:
 181 0056 C046     		.align	2
 182              	.L9:
 183 0058 91000F40 		.word	1074725009
 184 005c 90000F40 		.word	1074725008
 185 0060 92000F40 		.word	1074725010
 186              		.cfi_endproc
 187              	.LFE3:
 188              		.size	UART_Enable, .-UART_Enable
 189              		.section	.text.UART_Stop,"ax",%progbits
 190              		.align	2
 191              		.global	UART_Stop
 192              		.code	16
 193              		.thumb_func
 194              		.type	UART_Stop, %function
 195              	UART_Stop:
 196              	.LFB4:
 224:.\Generated_Source\PSoC4/UART.c **** 
 225:.\Generated_Source\PSoC4/UART.c **** 
 226:.\Generated_Source\PSoC4/UART.c **** /*******************************************************************************
 227:.\Generated_Source\PSoC4/UART.c **** * Function Name: UART_Stop
 228:.\Generated_Source\PSoC4/UART.c **** ********************************************************************************
 229:.\Generated_Source\PSoC4/UART.c **** *
 230:.\Generated_Source\PSoC4/UART.c **** * Summary:
 231:.\Generated_Source\PSoC4/UART.c **** *  Disables the UART operation.
 232:.\Generated_Source\PSoC4/UART.c **** *
 233:.\Generated_Source\PSoC4/UART.c **** * Parameters:
 234:.\Generated_Source\PSoC4/UART.c **** *  None.
 235:.\Generated_Source\PSoC4/UART.c **** *
 236:.\Generated_Source\PSoC4/UART.c **** * Return:
 237:.\Generated_Source\PSoC4/UART.c **** *  None.
 238:.\Generated_Source\PSoC4/UART.c **** *
 239:.\Generated_Source\PSoC4/UART.c **** *******************************************************************************/
 240:.\Generated_Source\PSoC4/UART.c **** void UART_Stop(void) 
 241:.\Generated_Source\PSoC4/UART.c **** {
 197              		.loc 1 241 0
 198              		.cfi_startproc
 199 0000 90B5     		push	{r4, r7, lr}
 200              		.cfi_def_cfa_offset 12
 201              		.cfi_offset 4, -12
 202              		.cfi_offset 7, -8
 203              		.cfi_offset 14, -4
 204 0002 83B0     		sub	sp, sp, #12
 205              		.cfi_def_cfa_offset 24
 206 0004 00AF     		add	r7, sp, #0
 207              		.cfi_def_cfa_register 7
 242:.\Generated_Source\PSoC4/UART.c ****     uint8 enableInterrupts;
 243:.\Generated_Source\PSoC4/UART.c ****     enableInterrupts = CyEnterCriticalSection();
 208              		.loc 1 243 0
 209 0006 FC1D     		add	r4, r7, #7
 210 0008 FFF7FEFF 		bl	CyEnterCriticalSection
 211 000c 031C     		mov	r3, r0
 212 000e 2370     		strb	r3, [r4]
 244:.\Generated_Source\PSoC4/UART.c **** 
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 9


 245:.\Generated_Source\PSoC4/UART.c ****     /* Write Bit Counter Disable */
 246:.\Generated_Source\PSoC4/UART.c ****     #if (UART_RX_ENABLED || UART_HD_ENABLED)
 247:.\Generated_Source\PSoC4/UART.c ****         UART_RXBITCTR_CONTROL_REG &= (uint8) ~UART_CNTR_ENABLE;
 213              		.loc 1 247 0
 214 0010 104B     		ldr	r3, .L12
 215 0012 104A     		ldr	r2, .L12
 216 0014 1278     		ldrb	r2, [r2]
 217 0016 D2B2     		uxtb	r2, r2
 218 0018 2021     		mov	r1, #32
 219 001a 8A43     		bic	r2, r1
 220 001c D2B2     		uxtb	r2, r2
 221 001e 1A70     		strb	r2, [r3]
 248:.\Generated_Source\PSoC4/UART.c ****     #endif /* (UART_RX_ENABLED || UART_HD_ENABLED) */
 249:.\Generated_Source\PSoC4/UART.c **** 
 250:.\Generated_Source\PSoC4/UART.c ****     #if (UART_TX_ENABLED)
 251:.\Generated_Source\PSoC4/UART.c ****         #if(!UART_TXCLKGEN_DP)
 252:.\Generated_Source\PSoC4/UART.c ****             UART_TXBITCTR_CONTROL_REG &= (uint8) ~UART_CNTR_ENABLE;
 253:.\Generated_Source\PSoC4/UART.c ****         #endif /* (!UART_TXCLKGEN_DP) */
 254:.\Generated_Source\PSoC4/UART.c ****     #endif /* (UART_TX_ENABLED) */
 255:.\Generated_Source\PSoC4/UART.c **** 
 256:.\Generated_Source\PSoC4/UART.c ****     #if (UART_INTERNAL_CLOCK_USED)
 257:.\Generated_Source\PSoC4/UART.c ****         UART_IntClock_Stop();   /* Disable the clock */
 222              		.loc 1 257 0
 223 0020 FFF7FEFF 		bl	UART_IntClock_Stop
 258:.\Generated_Source\PSoC4/UART.c ****     #endif /* (UART_INTERNAL_CLOCK_USED) */
 259:.\Generated_Source\PSoC4/UART.c **** 
 260:.\Generated_Source\PSoC4/UART.c ****     /* Disable internal interrupt component */
 261:.\Generated_Source\PSoC4/UART.c ****     #if (UART_RX_ENABLED || UART_HD_ENABLED)
 262:.\Generated_Source\PSoC4/UART.c ****         UART_RXSTATUS_ACTL_REG  &= (uint8) ~UART_INT_ENABLE;
 224              		.loc 1 262 0
 225 0024 0C4B     		ldr	r3, .L12+4
 226 0026 0C4A     		ldr	r2, .L12+4
 227 0028 1278     		ldrb	r2, [r2]
 228 002a D2B2     		uxtb	r2, r2
 229 002c 1021     		mov	r1, #16
 230 002e 8A43     		bic	r2, r1
 231 0030 D2B2     		uxtb	r2, r2
 232 0032 1A70     		strb	r2, [r3]
 263:.\Generated_Source\PSoC4/UART.c **** 
 264:.\Generated_Source\PSoC4/UART.c ****         #if (UART_RX_INTERRUPT_ENABLED)
 265:.\Generated_Source\PSoC4/UART.c ****             UART_DisableRxInt();
 266:.\Generated_Source\PSoC4/UART.c ****         #endif /* (UART_RX_INTERRUPT_ENABLED) */
 267:.\Generated_Source\PSoC4/UART.c ****     #endif /* (UART_RX_ENABLED || UART_HD_ENABLED) */
 268:.\Generated_Source\PSoC4/UART.c **** 
 269:.\Generated_Source\PSoC4/UART.c ****     #if (UART_TX_ENABLED)
 270:.\Generated_Source\PSoC4/UART.c ****         UART_TXSTATUS_ACTL_REG &= (uint8) ~UART_INT_ENABLE;
 233              		.loc 1 270 0
 234 0034 094B     		ldr	r3, .L12+8
 235 0036 094A     		ldr	r2, .L12+8
 236 0038 1278     		ldrb	r2, [r2]
 237 003a D2B2     		uxtb	r2, r2
 238 003c 1021     		mov	r1, #16
 239 003e 8A43     		bic	r2, r1
 240 0040 D2B2     		uxtb	r2, r2
 241 0042 1A70     		strb	r2, [r3]
 271:.\Generated_Source\PSoC4/UART.c **** 
 272:.\Generated_Source\PSoC4/UART.c ****         #if (UART_TX_INTERRUPT_ENABLED)
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 10


 273:.\Generated_Source\PSoC4/UART.c ****             UART_DisableTxInt();
 274:.\Generated_Source\PSoC4/UART.c ****         #endif /* (UART_TX_INTERRUPT_ENABLED) */
 275:.\Generated_Source\PSoC4/UART.c ****     #endif /* (UART_TX_ENABLED) */
 276:.\Generated_Source\PSoC4/UART.c **** 
 277:.\Generated_Source\PSoC4/UART.c ****     CyExitCriticalSection(enableInterrupts);
 242              		.loc 1 277 0
 243 0044 FB1D     		add	r3, r7, #7
 244 0046 1B78     		ldrb	r3, [r3]
 245 0048 181C     		mov	r0, r3
 246 004a FFF7FEFF 		bl	CyExitCriticalSection
 278:.\Generated_Source\PSoC4/UART.c **** }
 247              		.loc 1 278 0
 248 004e BD46     		mov	sp, r7
 249 0050 03B0     		add	sp, sp, #12
 250              		@ sp needed
 251 0052 90BD     		pop	{r4, r7, pc}
 252              	.L13:
 253              		.align	2
 254              	.L12:
 255 0054 91000F40 		.word	1074725009
 256 0058 90000F40 		.word	1074725008
 257 005c 92000F40 		.word	1074725010
 258              		.cfi_endproc
 259              	.LFE4:
 260              		.size	UART_Stop, .-UART_Stop
 261              		.section	.text.UART_ReadControlRegister,"ax",%progbits
 262              		.align	2
 263              		.global	UART_ReadControlRegister
 264              		.code	16
 265              		.thumb_func
 266              		.type	UART_ReadControlRegister, %function
 267              	UART_ReadControlRegister:
 268              	.LFB5:
 279:.\Generated_Source\PSoC4/UART.c **** 
 280:.\Generated_Source\PSoC4/UART.c **** 
 281:.\Generated_Source\PSoC4/UART.c **** /*******************************************************************************
 282:.\Generated_Source\PSoC4/UART.c **** * Function Name: UART_ReadControlRegister
 283:.\Generated_Source\PSoC4/UART.c **** ********************************************************************************
 284:.\Generated_Source\PSoC4/UART.c **** *
 285:.\Generated_Source\PSoC4/UART.c **** * Summary:
 286:.\Generated_Source\PSoC4/UART.c **** *  Returns the current value of the control register.
 287:.\Generated_Source\PSoC4/UART.c **** *
 288:.\Generated_Source\PSoC4/UART.c **** * Parameters:
 289:.\Generated_Source\PSoC4/UART.c **** *  None.
 290:.\Generated_Source\PSoC4/UART.c **** *
 291:.\Generated_Source\PSoC4/UART.c **** * Return:
 292:.\Generated_Source\PSoC4/UART.c **** *  Contents of the control register.
 293:.\Generated_Source\PSoC4/UART.c **** *
 294:.\Generated_Source\PSoC4/UART.c **** *******************************************************************************/
 295:.\Generated_Source\PSoC4/UART.c **** uint8 UART_ReadControlRegister(void) 
 296:.\Generated_Source\PSoC4/UART.c **** {
 269              		.loc 1 296 0
 270              		.cfi_startproc
 271 0000 80B5     		push	{r7, lr}
 272              		.cfi_def_cfa_offset 8
 273              		.cfi_offset 7, -8
 274              		.cfi_offset 14, -4
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 11


 275 0002 00AF     		add	r7, sp, #0
 276              		.cfi_def_cfa_register 7
 297:.\Generated_Source\PSoC4/UART.c ****     #if (UART_CONTROL_REG_REMOVED)
 298:.\Generated_Source\PSoC4/UART.c ****         return(0u);
 277              		.loc 1 298 0
 278 0004 0023     		mov	r3, #0
 299:.\Generated_Source\PSoC4/UART.c ****     #else
 300:.\Generated_Source\PSoC4/UART.c ****         return(UART_CONTROL_REG);
 301:.\Generated_Source\PSoC4/UART.c ****     #endif /* (UART_CONTROL_REG_REMOVED) */
 302:.\Generated_Source\PSoC4/UART.c **** }
 279              		.loc 1 302 0
 280 0006 181C     		mov	r0, r3
 281 0008 BD46     		mov	sp, r7
 282              		@ sp needed
 283 000a 80BD     		pop	{r7, pc}
 284              		.cfi_endproc
 285              	.LFE5:
 286              		.size	UART_ReadControlRegister, .-UART_ReadControlRegister
 287              		.section	.text.UART_WriteControlRegister,"ax",%progbits
 288              		.align	2
 289              		.global	UART_WriteControlRegister
 290              		.code	16
 291              		.thumb_func
 292              		.type	UART_WriteControlRegister, %function
 293              	UART_WriteControlRegister:
 294              	.LFB6:
 303:.\Generated_Source\PSoC4/UART.c **** 
 304:.\Generated_Source\PSoC4/UART.c **** 
 305:.\Generated_Source\PSoC4/UART.c **** /*******************************************************************************
 306:.\Generated_Source\PSoC4/UART.c **** * Function Name: UART_WriteControlRegister
 307:.\Generated_Source\PSoC4/UART.c **** ********************************************************************************
 308:.\Generated_Source\PSoC4/UART.c **** *
 309:.\Generated_Source\PSoC4/UART.c **** * Summary:
 310:.\Generated_Source\PSoC4/UART.c **** *  Writes an 8-bit value into the control register
 311:.\Generated_Source\PSoC4/UART.c **** *
 312:.\Generated_Source\PSoC4/UART.c **** * Parameters:
 313:.\Generated_Source\PSoC4/UART.c **** *  control:  control register value
 314:.\Generated_Source\PSoC4/UART.c **** *
 315:.\Generated_Source\PSoC4/UART.c **** * Return:
 316:.\Generated_Source\PSoC4/UART.c **** *  None.
 317:.\Generated_Source\PSoC4/UART.c **** *
 318:.\Generated_Source\PSoC4/UART.c **** *******************************************************************************/
 319:.\Generated_Source\PSoC4/UART.c **** void  UART_WriteControlRegister(uint8 control) 
 320:.\Generated_Source\PSoC4/UART.c **** {
 295              		.loc 1 320 0
 296              		.cfi_startproc
 297 0000 80B5     		push	{r7, lr}
 298              		.cfi_def_cfa_offset 8
 299              		.cfi_offset 7, -8
 300              		.cfi_offset 14, -4
 301 0002 82B0     		sub	sp, sp, #8
 302              		.cfi_def_cfa_offset 16
 303 0004 00AF     		add	r7, sp, #0
 304              		.cfi_def_cfa_register 7
 305 0006 021C     		mov	r2, r0
 306 0008 FB1D     		add	r3, r7, #7
 307 000a 1A70     		strb	r2, [r3]
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 12


 321:.\Generated_Source\PSoC4/UART.c ****     #if (UART_CONTROL_REG_REMOVED)
 322:.\Generated_Source\PSoC4/UART.c ****         if(0u != control)
 323:.\Generated_Source\PSoC4/UART.c ****         {
 324:.\Generated_Source\PSoC4/UART.c ****             /* Suppress compiler warning */
 325:.\Generated_Source\PSoC4/UART.c ****         }
 326:.\Generated_Source\PSoC4/UART.c ****     #else
 327:.\Generated_Source\PSoC4/UART.c ****        UART_CONTROL_REG = control;
 328:.\Generated_Source\PSoC4/UART.c ****     #endif /* (UART_CONTROL_REG_REMOVED) */
 329:.\Generated_Source\PSoC4/UART.c **** }
 308              		.loc 1 329 0
 309 000c BD46     		mov	sp, r7
 310 000e 02B0     		add	sp, sp, #8
 311              		@ sp needed
 312 0010 80BD     		pop	{r7, pc}
 313              		.cfi_endproc
 314              	.LFE6:
 315              		.size	UART_WriteControlRegister, .-UART_WriteControlRegister
 316 0012 C046     		.section	.text.UART_SetRxInterruptMode,"ax",%progbits
 317              		.align	2
 318              		.global	UART_SetRxInterruptMode
 319              		.code	16
 320              		.thumb_func
 321              		.type	UART_SetRxInterruptMode, %function
 322              	UART_SetRxInterruptMode:
 323              	.LFB7:
 330:.\Generated_Source\PSoC4/UART.c **** 
 331:.\Generated_Source\PSoC4/UART.c **** 
 332:.\Generated_Source\PSoC4/UART.c **** #if(UART_RX_ENABLED || UART_HD_ENABLED)
 333:.\Generated_Source\PSoC4/UART.c ****     /*******************************************************************************
 334:.\Generated_Source\PSoC4/UART.c ****     * Function Name: UART_SetRxInterruptMode
 335:.\Generated_Source\PSoC4/UART.c ****     ********************************************************************************
 336:.\Generated_Source\PSoC4/UART.c ****     *
 337:.\Generated_Source\PSoC4/UART.c ****     * Summary:
 338:.\Generated_Source\PSoC4/UART.c ****     *  Configures the RX interrupt sources enabled.
 339:.\Generated_Source\PSoC4/UART.c ****     *
 340:.\Generated_Source\PSoC4/UART.c ****     * Parameters:
 341:.\Generated_Source\PSoC4/UART.c ****     *  IntSrc:  Bit field containing the RX interrupts to enable. Based on the 
 342:.\Generated_Source\PSoC4/UART.c ****     *  bit-field arrangement of the status register. This value must be a 
 343:.\Generated_Source\PSoC4/UART.c ****     *  combination of status register bit-masks shown below:
 344:.\Generated_Source\PSoC4/UART.c ****     *      UART_RX_STS_FIFO_NOTEMPTY    Interrupt on byte received.
 345:.\Generated_Source\PSoC4/UART.c ****     *      UART_RX_STS_PAR_ERROR        Interrupt on parity error.
 346:.\Generated_Source\PSoC4/UART.c ****     *      UART_RX_STS_STOP_ERROR       Interrupt on stop error.
 347:.\Generated_Source\PSoC4/UART.c ****     *      UART_RX_STS_BREAK            Interrupt on break.
 348:.\Generated_Source\PSoC4/UART.c ****     *      UART_RX_STS_OVERRUN          Interrupt on overrun error.
 349:.\Generated_Source\PSoC4/UART.c ****     *      UART_RX_STS_ADDR_MATCH       Interrupt on address match.
 350:.\Generated_Source\PSoC4/UART.c ****     *      UART_RX_STS_MRKSPC           Interrupt on address detect.
 351:.\Generated_Source\PSoC4/UART.c ****     *
 352:.\Generated_Source\PSoC4/UART.c ****     * Return:
 353:.\Generated_Source\PSoC4/UART.c ****     *  None.
 354:.\Generated_Source\PSoC4/UART.c ****     *
 355:.\Generated_Source\PSoC4/UART.c ****     * Theory:
 356:.\Generated_Source\PSoC4/UART.c ****     *  Enables the output of specific status bits to the interrupt controller
 357:.\Generated_Source\PSoC4/UART.c ****     *
 358:.\Generated_Source\PSoC4/UART.c ****     *******************************************************************************/
 359:.\Generated_Source\PSoC4/UART.c ****     void UART_SetRxInterruptMode(uint8 intSrc) 
 360:.\Generated_Source\PSoC4/UART.c ****     {
 324              		.loc 1 360 0
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 13


 325              		.cfi_startproc
 326 0000 80B5     		push	{r7, lr}
 327              		.cfi_def_cfa_offset 8
 328              		.cfi_offset 7, -8
 329              		.cfi_offset 14, -4
 330 0002 82B0     		sub	sp, sp, #8
 331              		.cfi_def_cfa_offset 16
 332 0004 00AF     		add	r7, sp, #0
 333              		.cfi_def_cfa_register 7
 334 0006 021C     		mov	r2, r0
 335 0008 FB1D     		add	r3, r7, #7
 336 000a 1A70     		strb	r2, [r3]
 361:.\Generated_Source\PSoC4/UART.c ****         UART_RXSTATUS_MASK_REG  = intSrc;
 337              		.loc 1 361 0
 338 000c 034B     		ldr	r3, .L18
 339 000e FA1D     		add	r2, r7, #7
 340 0010 1278     		ldrb	r2, [r2]
 341 0012 1A70     		strb	r2, [r3]
 362:.\Generated_Source\PSoC4/UART.c ****     }
 342              		.loc 1 362 0
 343 0014 BD46     		mov	sp, r7
 344 0016 02B0     		add	sp, sp, #8
 345              		@ sp needed
 346 0018 80BD     		pop	{r7, pc}
 347              	.L19:
 348 001a C046     		.align	2
 349              	.L18:
 350 001c 80000F40 		.word	1074724992
 351              		.cfi_endproc
 352              	.LFE7:
 353              		.size	UART_SetRxInterruptMode, .-UART_SetRxInterruptMode
 354              		.section	.text.UART_ReadRxData,"ax",%progbits
 355              		.align	2
 356              		.global	UART_ReadRxData
 357              		.code	16
 358              		.thumb_func
 359              		.type	UART_ReadRxData, %function
 360              	UART_ReadRxData:
 361              	.LFB8:
 363:.\Generated_Source\PSoC4/UART.c **** 
 364:.\Generated_Source\PSoC4/UART.c **** 
 365:.\Generated_Source\PSoC4/UART.c ****     /*******************************************************************************
 366:.\Generated_Source\PSoC4/UART.c ****     * Function Name: UART_ReadRxData
 367:.\Generated_Source\PSoC4/UART.c ****     ********************************************************************************
 368:.\Generated_Source\PSoC4/UART.c ****     *
 369:.\Generated_Source\PSoC4/UART.c ****     * Summary:
 370:.\Generated_Source\PSoC4/UART.c ****     *  Returns the next byte of received data. This function returns data without
 371:.\Generated_Source\PSoC4/UART.c ****     *  checking the status. You must check the status separately.
 372:.\Generated_Source\PSoC4/UART.c ****     *
 373:.\Generated_Source\PSoC4/UART.c ****     * Parameters:
 374:.\Generated_Source\PSoC4/UART.c ****     *  None.
 375:.\Generated_Source\PSoC4/UART.c ****     *
 376:.\Generated_Source\PSoC4/UART.c ****     * Return:
 377:.\Generated_Source\PSoC4/UART.c ****     *  Received data from RX register
 378:.\Generated_Source\PSoC4/UART.c ****     *
 379:.\Generated_Source\PSoC4/UART.c ****     * Global Variables:
 380:.\Generated_Source\PSoC4/UART.c ****     *  UART_rxBuffer - RAM buffer pointer for save received data.
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 14


 381:.\Generated_Source\PSoC4/UART.c ****     *  UART_rxBufferWrite - cyclic index for write to rxBuffer,
 382:.\Generated_Source\PSoC4/UART.c ****     *     checked to identify new data.
 383:.\Generated_Source\PSoC4/UART.c ****     *  UART_rxBufferRead - cyclic index for read from rxBuffer,
 384:.\Generated_Source\PSoC4/UART.c ****     *     incremented after each byte has been read from buffer.
 385:.\Generated_Source\PSoC4/UART.c ****     *  UART_rxBufferLoopDetect - cleared if loop condition was detected
 386:.\Generated_Source\PSoC4/UART.c ****     *     in RX ISR.
 387:.\Generated_Source\PSoC4/UART.c ****     *
 388:.\Generated_Source\PSoC4/UART.c ****     * Reentrant:
 389:.\Generated_Source\PSoC4/UART.c ****     *  No.
 390:.\Generated_Source\PSoC4/UART.c ****     *
 391:.\Generated_Source\PSoC4/UART.c ****     *******************************************************************************/
 392:.\Generated_Source\PSoC4/UART.c ****     uint8 UART_ReadRxData(void) 
 393:.\Generated_Source\PSoC4/UART.c ****     {
 362              		.loc 1 393 0
 363              		.cfi_startproc
 364 0000 80B5     		push	{r7, lr}
 365              		.cfi_def_cfa_offset 8
 366              		.cfi_offset 7, -8
 367              		.cfi_offset 14, -4
 368 0002 82B0     		sub	sp, sp, #8
 369              		.cfi_def_cfa_offset 16
 370 0004 00AF     		add	r7, sp, #0
 371              		.cfi_def_cfa_register 7
 394:.\Generated_Source\PSoC4/UART.c ****         uint8 rxData;
 395:.\Generated_Source\PSoC4/UART.c **** 
 396:.\Generated_Source\PSoC4/UART.c ****     #if (UART_RX_INTERRUPT_ENABLED)
 397:.\Generated_Source\PSoC4/UART.c **** 
 398:.\Generated_Source\PSoC4/UART.c ****         uint8 locRxBufferRead;
 399:.\Generated_Source\PSoC4/UART.c ****         uint8 locRxBufferWrite;
 400:.\Generated_Source\PSoC4/UART.c **** 
 401:.\Generated_Source\PSoC4/UART.c ****         /* Protect variables that could change on interrupt */
 402:.\Generated_Source\PSoC4/UART.c ****         UART_DisableRxInt();
 403:.\Generated_Source\PSoC4/UART.c **** 
 404:.\Generated_Source\PSoC4/UART.c ****         locRxBufferRead  = UART_rxBufferRead;
 405:.\Generated_Source\PSoC4/UART.c ****         locRxBufferWrite = UART_rxBufferWrite;
 406:.\Generated_Source\PSoC4/UART.c **** 
 407:.\Generated_Source\PSoC4/UART.c ****         if( (UART_rxBufferLoopDetect != 0u) || (locRxBufferRead != locRxBufferWrite) )
 408:.\Generated_Source\PSoC4/UART.c ****         {
 409:.\Generated_Source\PSoC4/UART.c ****             rxData = UART_rxBuffer[locRxBufferRead];
 410:.\Generated_Source\PSoC4/UART.c ****             locRxBufferRead++;
 411:.\Generated_Source\PSoC4/UART.c **** 
 412:.\Generated_Source\PSoC4/UART.c ****             if(locRxBufferRead >= UART_RX_BUFFER_SIZE)
 413:.\Generated_Source\PSoC4/UART.c ****             {
 414:.\Generated_Source\PSoC4/UART.c ****                 locRxBufferRead = 0u;
 415:.\Generated_Source\PSoC4/UART.c ****             }
 416:.\Generated_Source\PSoC4/UART.c ****             /* Update the real pointer */
 417:.\Generated_Source\PSoC4/UART.c ****             UART_rxBufferRead = locRxBufferRead;
 418:.\Generated_Source\PSoC4/UART.c **** 
 419:.\Generated_Source\PSoC4/UART.c ****             if(UART_rxBufferLoopDetect != 0u)
 420:.\Generated_Source\PSoC4/UART.c ****             {
 421:.\Generated_Source\PSoC4/UART.c ****                 UART_rxBufferLoopDetect = 0u;
 422:.\Generated_Source\PSoC4/UART.c ****                 #if ((UART_RX_INTERRUPT_ENABLED) && (UART_FLOW_CONTROL != 0u))
 423:.\Generated_Source\PSoC4/UART.c ****                     /* When Hardware Flow Control selected - return RX mask */
 424:.\Generated_Source\PSoC4/UART.c ****                     #if( UART_HD_ENABLED )
 425:.\Generated_Source\PSoC4/UART.c ****                         if((UART_CONTROL_REG & UART_CTRL_HD_SEND) == 0u)
 426:.\Generated_Source\PSoC4/UART.c ****                         {   /* In Half duplex mode return RX mask only in RX
 427:.\Generated_Source\PSoC4/UART.c ****                             *  configuration set, otherwise
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 15


 428:.\Generated_Source\PSoC4/UART.c ****                             *  mask will be returned in LoadRxConfig() API.
 429:.\Generated_Source\PSoC4/UART.c ****                             */
 430:.\Generated_Source\PSoC4/UART.c ****                             UART_RXSTATUS_MASK_REG  |= UART_RX_STS_FIFO_NOTEMPTY;
 431:.\Generated_Source\PSoC4/UART.c ****                         }
 432:.\Generated_Source\PSoC4/UART.c ****                     #else
 433:.\Generated_Source\PSoC4/UART.c ****                         UART_RXSTATUS_MASK_REG  |= UART_RX_STS_FIFO_NOTEMPTY;
 434:.\Generated_Source\PSoC4/UART.c ****                     #endif /* end UART_HD_ENABLED */
 435:.\Generated_Source\PSoC4/UART.c ****                 #endif /* ((UART_RX_INTERRUPT_ENABLED) && (UART_FLOW_CONTROL != 0u)) */
 436:.\Generated_Source\PSoC4/UART.c ****             }
 437:.\Generated_Source\PSoC4/UART.c ****         }
 438:.\Generated_Source\PSoC4/UART.c ****         else
 439:.\Generated_Source\PSoC4/UART.c ****         {   /* Needs to check status for RX_STS_FIFO_NOTEMPTY bit */
 440:.\Generated_Source\PSoC4/UART.c ****             rxData = UART_RXDATA_REG;
 441:.\Generated_Source\PSoC4/UART.c ****         }
 442:.\Generated_Source\PSoC4/UART.c **** 
 443:.\Generated_Source\PSoC4/UART.c ****         UART_EnableRxInt();
 444:.\Generated_Source\PSoC4/UART.c **** 
 445:.\Generated_Source\PSoC4/UART.c ****     #else
 446:.\Generated_Source\PSoC4/UART.c **** 
 447:.\Generated_Source\PSoC4/UART.c ****         /* Needs to check status for RX_STS_FIFO_NOTEMPTY bit */
 448:.\Generated_Source\PSoC4/UART.c ****         rxData = UART_RXDATA_REG;
 372              		.loc 1 448 0
 373 0006 054A     		ldr	r2, .L22
 374 0008 FB1D     		add	r3, r7, #7
 375 000a 1278     		ldrb	r2, [r2]
 376 000c 1A70     		strb	r2, [r3]
 449:.\Generated_Source\PSoC4/UART.c **** 
 450:.\Generated_Source\PSoC4/UART.c ****     #endif /* (UART_RX_INTERRUPT_ENABLED) */
 451:.\Generated_Source\PSoC4/UART.c **** 
 452:.\Generated_Source\PSoC4/UART.c ****         return(rxData);
 377              		.loc 1 452 0
 378 000e FB1D     		add	r3, r7, #7
 379 0010 1B78     		ldrb	r3, [r3]
 453:.\Generated_Source\PSoC4/UART.c ****     }
 380              		.loc 1 453 0
 381 0012 181C     		mov	r0, r3
 382 0014 BD46     		mov	sp, r7
 383 0016 02B0     		add	sp, sp, #8
 384              		@ sp needed
 385 0018 80BD     		pop	{r7, pc}
 386              	.L23:
 387 001a C046     		.align	2
 388              	.L22:
 389 001c 41000F40 		.word	1074724929
 390              		.cfi_endproc
 391              	.LFE8:
 392              		.size	UART_ReadRxData, .-UART_ReadRxData
 393              		.section	.text.UART_ReadRxStatus,"ax",%progbits
 394              		.align	2
 395              		.global	UART_ReadRxStatus
 396              		.code	16
 397              		.thumb_func
 398              		.type	UART_ReadRxStatus, %function
 399              	UART_ReadRxStatus:
 400              	.LFB9:
 454:.\Generated_Source\PSoC4/UART.c **** 
 455:.\Generated_Source\PSoC4/UART.c **** 
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 16


 456:.\Generated_Source\PSoC4/UART.c ****     /*******************************************************************************
 457:.\Generated_Source\PSoC4/UART.c ****     * Function Name: UART_ReadRxStatus
 458:.\Generated_Source\PSoC4/UART.c ****     ********************************************************************************
 459:.\Generated_Source\PSoC4/UART.c ****     *
 460:.\Generated_Source\PSoC4/UART.c ****     * Summary:
 461:.\Generated_Source\PSoC4/UART.c ****     *  Returns the current state of the receiver status register and the software
 462:.\Generated_Source\PSoC4/UART.c ****     *  buffer overflow status.
 463:.\Generated_Source\PSoC4/UART.c ****     *
 464:.\Generated_Source\PSoC4/UART.c ****     * Parameters:
 465:.\Generated_Source\PSoC4/UART.c ****     *  None.
 466:.\Generated_Source\PSoC4/UART.c ****     *
 467:.\Generated_Source\PSoC4/UART.c ****     * Return:
 468:.\Generated_Source\PSoC4/UART.c ****     *  Current state of the status register.
 469:.\Generated_Source\PSoC4/UART.c ****     *
 470:.\Generated_Source\PSoC4/UART.c ****     * Side Effect:
 471:.\Generated_Source\PSoC4/UART.c ****     *  All status register bits are clear-on-read except
 472:.\Generated_Source\PSoC4/UART.c ****     *  UART_RX_STS_FIFO_NOTEMPTY.
 473:.\Generated_Source\PSoC4/UART.c ****     *  UART_RX_STS_FIFO_NOTEMPTY clears immediately after RX data
 474:.\Generated_Source\PSoC4/UART.c ****     *  register read.
 475:.\Generated_Source\PSoC4/UART.c ****     *
 476:.\Generated_Source\PSoC4/UART.c ****     * Global Variables:
 477:.\Generated_Source\PSoC4/UART.c ****     *  UART_rxBufferOverflow - used to indicate overload condition.
 478:.\Generated_Source\PSoC4/UART.c ****     *   It set to one in RX interrupt when there isn't free space in
 479:.\Generated_Source\PSoC4/UART.c ****     *   UART_rxBufferRead to write new data. This condition returned
 480:.\Generated_Source\PSoC4/UART.c ****     *   and cleared to zero by this API as an
 481:.\Generated_Source\PSoC4/UART.c ****     *   UART_RX_STS_SOFT_BUFF_OVER bit along with RX Status register
 482:.\Generated_Source\PSoC4/UART.c ****     *   bits.
 483:.\Generated_Source\PSoC4/UART.c ****     *
 484:.\Generated_Source\PSoC4/UART.c ****     *******************************************************************************/
 485:.\Generated_Source\PSoC4/UART.c ****     uint8 UART_ReadRxStatus(void) 
 486:.\Generated_Source\PSoC4/UART.c ****     {
 401              		.loc 1 486 0
 402              		.cfi_startproc
 403 0000 80B5     		push	{r7, lr}
 404              		.cfi_def_cfa_offset 8
 405              		.cfi_offset 7, -8
 406              		.cfi_offset 14, -4
 407 0002 82B0     		sub	sp, sp, #8
 408              		.cfi_def_cfa_offset 16
 409 0004 00AF     		add	r7, sp, #0
 410              		.cfi_def_cfa_register 7
 487:.\Generated_Source\PSoC4/UART.c ****         uint8 status;
 488:.\Generated_Source\PSoC4/UART.c **** 
 489:.\Generated_Source\PSoC4/UART.c ****         status = UART_RXSTATUS_REG & UART_RX_HW_MASK;
 411              		.loc 1 489 0
 412 0006 064B     		ldr	r3, .L26
 413 0008 1B78     		ldrb	r3, [r3]
 414 000a D9B2     		uxtb	r1, r3
 415 000c FB1D     		add	r3, r7, #7
 416 000e 7F22     		mov	r2, #127
 417 0010 0A40     		and	r2, r1
 418 0012 1A70     		strb	r2, [r3]
 490:.\Generated_Source\PSoC4/UART.c **** 
 491:.\Generated_Source\PSoC4/UART.c ****     #if (UART_RX_INTERRUPT_ENABLED)
 492:.\Generated_Source\PSoC4/UART.c ****         if(UART_rxBufferOverflow != 0u)
 493:.\Generated_Source\PSoC4/UART.c ****         {
 494:.\Generated_Source\PSoC4/UART.c ****             status |= UART_RX_STS_SOFT_BUFF_OVER;
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 17


 495:.\Generated_Source\PSoC4/UART.c ****             UART_rxBufferOverflow = 0u;
 496:.\Generated_Source\PSoC4/UART.c ****         }
 497:.\Generated_Source\PSoC4/UART.c ****     #endif /* (UART_RX_INTERRUPT_ENABLED) */
 498:.\Generated_Source\PSoC4/UART.c **** 
 499:.\Generated_Source\PSoC4/UART.c ****         return(status);
 419              		.loc 1 499 0
 420 0014 FB1D     		add	r3, r7, #7
 421 0016 1B78     		ldrb	r3, [r3]
 500:.\Generated_Source\PSoC4/UART.c ****     }
 422              		.loc 1 500 0
 423 0018 181C     		mov	r0, r3
 424 001a BD46     		mov	sp, r7
 425 001c 02B0     		add	sp, sp, #8
 426              		@ sp needed
 427 001e 80BD     		pop	{r7, pc}
 428              	.L27:
 429              		.align	2
 430              	.L26:
 431 0020 60000F40 		.word	1074724960
 432              		.cfi_endproc
 433              	.LFE9:
 434              		.size	UART_ReadRxStatus, .-UART_ReadRxStatus
 435              		.section	.text.UART_GetChar,"ax",%progbits
 436              		.align	2
 437              		.global	UART_GetChar
 438              		.code	16
 439              		.thumb_func
 440              		.type	UART_GetChar, %function
 441              	UART_GetChar:
 442              	.LFB10:
 501:.\Generated_Source\PSoC4/UART.c **** 
 502:.\Generated_Source\PSoC4/UART.c **** 
 503:.\Generated_Source\PSoC4/UART.c ****     /*******************************************************************************
 504:.\Generated_Source\PSoC4/UART.c ****     * Function Name: UART_GetChar
 505:.\Generated_Source\PSoC4/UART.c ****     ********************************************************************************
 506:.\Generated_Source\PSoC4/UART.c ****     *
 507:.\Generated_Source\PSoC4/UART.c ****     * Summary:
 508:.\Generated_Source\PSoC4/UART.c ****     *  Returns the last received byte of data. UART_GetChar() is
 509:.\Generated_Source\PSoC4/UART.c ****     *  designed for ASCII characters and returns a uint8 where 1 to 255 are values
 510:.\Generated_Source\PSoC4/UART.c ****     *  for valid characters and 0 indicates an error occurred or no data is present.
 511:.\Generated_Source\PSoC4/UART.c ****     *
 512:.\Generated_Source\PSoC4/UART.c ****     * Parameters:
 513:.\Generated_Source\PSoC4/UART.c ****     *  None.
 514:.\Generated_Source\PSoC4/UART.c ****     *
 515:.\Generated_Source\PSoC4/UART.c ****     * Return:
 516:.\Generated_Source\PSoC4/UART.c ****     *  Character read from UART RX buffer. ASCII characters from 1 to 255 are valid.
 517:.\Generated_Source\PSoC4/UART.c ****     *  A returned zero signifies an error condition or no data available.
 518:.\Generated_Source\PSoC4/UART.c ****     *
 519:.\Generated_Source\PSoC4/UART.c ****     * Global Variables:
 520:.\Generated_Source\PSoC4/UART.c ****     *  UART_rxBuffer - RAM buffer pointer for save received data.
 521:.\Generated_Source\PSoC4/UART.c ****     *  UART_rxBufferWrite - cyclic index for write to rxBuffer,
 522:.\Generated_Source\PSoC4/UART.c ****     *     checked to identify new data.
 523:.\Generated_Source\PSoC4/UART.c ****     *  UART_rxBufferRead - cyclic index for read from rxBuffer,
 524:.\Generated_Source\PSoC4/UART.c ****     *     incremented after each byte has been read from buffer.
 525:.\Generated_Source\PSoC4/UART.c ****     *  UART_rxBufferLoopDetect - cleared if loop condition was detected
 526:.\Generated_Source\PSoC4/UART.c ****     *     in RX ISR.
 527:.\Generated_Source\PSoC4/UART.c ****     *
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 18


 528:.\Generated_Source\PSoC4/UART.c ****     * Reentrant:
 529:.\Generated_Source\PSoC4/UART.c ****     *  No.
 530:.\Generated_Source\PSoC4/UART.c ****     *
 531:.\Generated_Source\PSoC4/UART.c ****     *******************************************************************************/
 532:.\Generated_Source\PSoC4/UART.c ****     uint8 UART_GetChar(void) 
 533:.\Generated_Source\PSoC4/UART.c ****     {
 443              		.loc 1 533 0
 444              		.cfi_startproc
 445 0000 80B5     		push	{r7, lr}
 446              		.cfi_def_cfa_offset 8
 447              		.cfi_offset 7, -8
 448              		.cfi_offset 14, -4
 449 0002 82B0     		sub	sp, sp, #8
 450              		.cfi_def_cfa_offset 16
 451 0004 00AF     		add	r7, sp, #0
 452              		.cfi_def_cfa_register 7
 534:.\Generated_Source\PSoC4/UART.c ****         uint8 rxData = 0u;
 453              		.loc 1 534 0
 454 0006 FB1D     		add	r3, r7, #7
 455 0008 0022     		mov	r2, #0
 456 000a 1A70     		strb	r2, [r3]
 535:.\Generated_Source\PSoC4/UART.c ****         uint8 rxStatus;
 536:.\Generated_Source\PSoC4/UART.c **** 
 537:.\Generated_Source\PSoC4/UART.c ****     #if (UART_RX_INTERRUPT_ENABLED)
 538:.\Generated_Source\PSoC4/UART.c ****         uint8 locRxBufferRead;
 539:.\Generated_Source\PSoC4/UART.c ****         uint8 locRxBufferWrite;
 540:.\Generated_Source\PSoC4/UART.c **** 
 541:.\Generated_Source\PSoC4/UART.c ****         /* Protect variables that could change on interrupt */
 542:.\Generated_Source\PSoC4/UART.c ****         UART_DisableRxInt();
 543:.\Generated_Source\PSoC4/UART.c **** 
 544:.\Generated_Source\PSoC4/UART.c ****         locRxBufferRead  = UART_rxBufferRead;
 545:.\Generated_Source\PSoC4/UART.c ****         locRxBufferWrite = UART_rxBufferWrite;
 546:.\Generated_Source\PSoC4/UART.c **** 
 547:.\Generated_Source\PSoC4/UART.c ****         if( (UART_rxBufferLoopDetect != 0u) || (locRxBufferRead != locRxBufferWrite) )
 548:.\Generated_Source\PSoC4/UART.c ****         {
 549:.\Generated_Source\PSoC4/UART.c ****             rxData = UART_rxBuffer[locRxBufferRead];
 550:.\Generated_Source\PSoC4/UART.c ****             locRxBufferRead++;
 551:.\Generated_Source\PSoC4/UART.c ****             if(locRxBufferRead >= UART_RX_BUFFER_SIZE)
 552:.\Generated_Source\PSoC4/UART.c ****             {
 553:.\Generated_Source\PSoC4/UART.c ****                 locRxBufferRead = 0u;
 554:.\Generated_Source\PSoC4/UART.c ****             }
 555:.\Generated_Source\PSoC4/UART.c ****             /* Update the real pointer */
 556:.\Generated_Source\PSoC4/UART.c ****             UART_rxBufferRead = locRxBufferRead;
 557:.\Generated_Source\PSoC4/UART.c **** 
 558:.\Generated_Source\PSoC4/UART.c ****             if(UART_rxBufferLoopDetect != 0u)
 559:.\Generated_Source\PSoC4/UART.c ****             {
 560:.\Generated_Source\PSoC4/UART.c ****                 UART_rxBufferLoopDetect = 0u;
 561:.\Generated_Source\PSoC4/UART.c ****                 #if( (UART_RX_INTERRUPT_ENABLED) && (UART_FLOW_CONTROL != 0u) )
 562:.\Generated_Source\PSoC4/UART.c ****                     /* When Hardware Flow Control selected - return RX mask */
 563:.\Generated_Source\PSoC4/UART.c ****                     #if( UART_HD_ENABLED )
 564:.\Generated_Source\PSoC4/UART.c ****                         if((UART_CONTROL_REG & UART_CTRL_HD_SEND) == 0u)
 565:.\Generated_Source\PSoC4/UART.c ****                         {   /* In Half duplex mode return RX mask only if
 566:.\Generated_Source\PSoC4/UART.c ****                             *  RX configuration set, otherwise
 567:.\Generated_Source\PSoC4/UART.c ****                             *  mask will be returned in LoadRxConfig() API.
 568:.\Generated_Source\PSoC4/UART.c ****                             */
 569:.\Generated_Source\PSoC4/UART.c ****                             UART_RXSTATUS_MASK_REG |= UART_RX_STS_FIFO_NOTEMPTY;
 570:.\Generated_Source\PSoC4/UART.c ****                         }
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 19


 571:.\Generated_Source\PSoC4/UART.c ****                     #else
 572:.\Generated_Source\PSoC4/UART.c ****                         UART_RXSTATUS_MASK_REG |= UART_RX_STS_FIFO_NOTEMPTY;
 573:.\Generated_Source\PSoC4/UART.c ****                     #endif /* end UART_HD_ENABLED */
 574:.\Generated_Source\PSoC4/UART.c ****                 #endif /* UART_RX_INTERRUPT_ENABLED and Hardware flow control*/
 575:.\Generated_Source\PSoC4/UART.c ****             }
 576:.\Generated_Source\PSoC4/UART.c **** 
 577:.\Generated_Source\PSoC4/UART.c ****         }
 578:.\Generated_Source\PSoC4/UART.c ****         else
 579:.\Generated_Source\PSoC4/UART.c ****         {   rxStatus = UART_RXSTATUS_REG;
 580:.\Generated_Source\PSoC4/UART.c ****             if((rxStatus & UART_RX_STS_FIFO_NOTEMPTY) != 0u)
 581:.\Generated_Source\PSoC4/UART.c ****             {   /* Read received data from FIFO */
 582:.\Generated_Source\PSoC4/UART.c ****                 rxData = UART_RXDATA_REG;
 583:.\Generated_Source\PSoC4/UART.c ****                 /*Check status on error*/
 584:.\Generated_Source\PSoC4/UART.c ****                 if((rxStatus & (UART_RX_STS_BREAK | UART_RX_STS_PAR_ERROR |
 585:.\Generated_Source\PSoC4/UART.c ****                                 UART_RX_STS_STOP_ERROR | UART_RX_STS_OVERRUN)) != 0u)
 586:.\Generated_Source\PSoC4/UART.c ****                 {
 587:.\Generated_Source\PSoC4/UART.c ****                     rxData = 0u;
 588:.\Generated_Source\PSoC4/UART.c ****                 }
 589:.\Generated_Source\PSoC4/UART.c ****             }
 590:.\Generated_Source\PSoC4/UART.c ****         }
 591:.\Generated_Source\PSoC4/UART.c **** 
 592:.\Generated_Source\PSoC4/UART.c ****         UART_EnableRxInt();
 593:.\Generated_Source\PSoC4/UART.c **** 
 594:.\Generated_Source\PSoC4/UART.c ****     #else
 595:.\Generated_Source\PSoC4/UART.c **** 
 596:.\Generated_Source\PSoC4/UART.c ****         rxStatus =UART_RXSTATUS_REG;
 457              		.loc 1 596 0
 458 000c 0D4A     		ldr	r2, .L31
 459 000e BB1D     		add	r3, r7, #6
 460 0010 1278     		ldrb	r2, [r2]
 461 0012 1A70     		strb	r2, [r3]
 597:.\Generated_Source\PSoC4/UART.c ****         if((rxStatus & UART_RX_STS_FIFO_NOTEMPTY) != 0u)
 462              		.loc 1 597 0
 463 0014 BB1D     		add	r3, r7, #6
 464 0016 1A78     		ldrb	r2, [r3]
 465 0018 2023     		mov	r3, #32
 466 001a 1340     		and	r3, r2
 467 001c 0BD0     		beq	.L29
 598:.\Generated_Source\PSoC4/UART.c ****         {
 599:.\Generated_Source\PSoC4/UART.c ****             /* Read received data from FIFO */
 600:.\Generated_Source\PSoC4/UART.c ****             rxData = UART_RXDATA_REG;
 468              		.loc 1 600 0
 469 001e 0A4A     		ldr	r2, .L31+4
 470 0020 FB1D     		add	r3, r7, #7
 471 0022 1278     		ldrb	r2, [r2]
 472 0024 1A70     		strb	r2, [r3]
 601:.\Generated_Source\PSoC4/UART.c **** 
 602:.\Generated_Source\PSoC4/UART.c ****             /*Check status on error*/
 603:.\Generated_Source\PSoC4/UART.c ****             if((rxStatus & (UART_RX_STS_BREAK | UART_RX_STS_PAR_ERROR |
 604:.\Generated_Source\PSoC4/UART.c ****                             UART_RX_STS_STOP_ERROR | UART_RX_STS_OVERRUN)) != 0u)
 473              		.loc 1 604 0
 474 0026 BB1D     		add	r3, r7, #6
 475 0028 1A78     		ldrb	r2, [r3]
 476 002a 1E23     		mov	r3, #30
 477 002c 1340     		and	r3, r2
 603:.\Generated_Source\PSoC4/UART.c ****             if((rxStatus & (UART_RX_STS_BREAK | UART_RX_STS_PAR_ERROR |
 478              		.loc 1 603 0
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 20


 479 002e 02D0     		beq	.L29
 605:.\Generated_Source\PSoC4/UART.c ****             {
 606:.\Generated_Source\PSoC4/UART.c ****                 rxData = 0u;
 480              		.loc 1 606 0
 481 0030 FB1D     		add	r3, r7, #7
 482 0032 0022     		mov	r2, #0
 483 0034 1A70     		strb	r2, [r3]
 484              	.L29:
 607:.\Generated_Source\PSoC4/UART.c ****             }
 608:.\Generated_Source\PSoC4/UART.c ****         }
 609:.\Generated_Source\PSoC4/UART.c ****     #endif /* (UART_RX_INTERRUPT_ENABLED) */
 610:.\Generated_Source\PSoC4/UART.c **** 
 611:.\Generated_Source\PSoC4/UART.c ****         return(rxData);
 485              		.loc 1 611 0
 486 0036 FB1D     		add	r3, r7, #7
 487 0038 1B78     		ldrb	r3, [r3]
 612:.\Generated_Source\PSoC4/UART.c ****     }
 488              		.loc 1 612 0
 489 003a 181C     		mov	r0, r3
 490 003c BD46     		mov	sp, r7
 491 003e 02B0     		add	sp, sp, #8
 492              		@ sp needed
 493 0040 80BD     		pop	{r7, pc}
 494              	.L32:
 495 0042 C046     		.align	2
 496              	.L31:
 497 0044 60000F40 		.word	1074724960
 498 0048 41000F40 		.word	1074724929
 499              		.cfi_endproc
 500              	.LFE10:
 501              		.size	UART_GetChar, .-UART_GetChar
 502              		.section	.text.UART_GetByte,"ax",%progbits
 503              		.align	2
 504              		.global	UART_GetByte
 505              		.code	16
 506              		.thumb_func
 507              		.type	UART_GetByte, %function
 508              	UART_GetByte:
 509              	.LFB11:
 613:.\Generated_Source\PSoC4/UART.c **** 
 614:.\Generated_Source\PSoC4/UART.c **** 
 615:.\Generated_Source\PSoC4/UART.c ****     /*******************************************************************************
 616:.\Generated_Source\PSoC4/UART.c ****     * Function Name: UART_GetByte
 617:.\Generated_Source\PSoC4/UART.c ****     ********************************************************************************
 618:.\Generated_Source\PSoC4/UART.c ****     *
 619:.\Generated_Source\PSoC4/UART.c ****     * Summary:
 620:.\Generated_Source\PSoC4/UART.c ****     *  Reads UART RX buffer immediately, returns received character and error
 621:.\Generated_Source\PSoC4/UART.c ****     *  condition.
 622:.\Generated_Source\PSoC4/UART.c ****     *
 623:.\Generated_Source\PSoC4/UART.c ****     * Parameters:
 624:.\Generated_Source\PSoC4/UART.c ****     *  None.
 625:.\Generated_Source\PSoC4/UART.c ****     *
 626:.\Generated_Source\PSoC4/UART.c ****     * Return:
 627:.\Generated_Source\PSoC4/UART.c ****     *  MSB contains status and LSB contains UART RX data. If the MSB is nonzero,
 628:.\Generated_Source\PSoC4/UART.c ****     *  an error has occurred.
 629:.\Generated_Source\PSoC4/UART.c ****     *
 630:.\Generated_Source\PSoC4/UART.c ****     * Reentrant:
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 21


 631:.\Generated_Source\PSoC4/UART.c ****     *  No.
 632:.\Generated_Source\PSoC4/UART.c ****     *
 633:.\Generated_Source\PSoC4/UART.c ****     *******************************************************************************/
 634:.\Generated_Source\PSoC4/UART.c ****     uint16 UART_GetByte(void) 
 635:.\Generated_Source\PSoC4/UART.c ****     {
 510              		.loc 1 635 0
 511              		.cfi_startproc
 512 0000 98B5     		push	{r3, r4, r7, lr}
 513              		.cfi_def_cfa_offset 16
 514              		.cfi_offset 3, -16
 515              		.cfi_offset 4, -12
 516              		.cfi_offset 7, -8
 517              		.cfi_offset 14, -4
 518 0002 00AF     		add	r7, sp, #0
 519              		.cfi_def_cfa_register 7
 636:.\Generated_Source\PSoC4/UART.c ****         
 637:.\Generated_Source\PSoC4/UART.c ****     #if (UART_RX_INTERRUPT_ENABLED)
 638:.\Generated_Source\PSoC4/UART.c ****         uint16 locErrorStatus;
 639:.\Generated_Source\PSoC4/UART.c ****         /* Protect variables that could change on interrupt */
 640:.\Generated_Source\PSoC4/UART.c ****         UART_DisableRxInt();
 641:.\Generated_Source\PSoC4/UART.c ****         locErrorStatus = (uint16)UART_errorStatus;
 642:.\Generated_Source\PSoC4/UART.c ****         UART_errorStatus = 0u;
 643:.\Generated_Source\PSoC4/UART.c ****         UART_EnableRxInt();
 644:.\Generated_Source\PSoC4/UART.c ****         return ( (uint16)(locErrorStatus << 8u) | UART_ReadRxData() );
 645:.\Generated_Source\PSoC4/UART.c ****     #else
 646:.\Generated_Source\PSoC4/UART.c ****         return ( ((uint16)UART_ReadRxStatus() << 8u) | UART_ReadRxData() );
 520              		.loc 1 646 0
 521 0004 FFF7FEFF 		bl	UART_ReadRxStatus
 522 0008 031C     		mov	r3, r0
 523 000a 1B02     		lsl	r3, r3, #8
 524 000c 9CB2     		uxth	r4, r3
 525 000e FFF7FEFF 		bl	UART_ReadRxData
 526 0012 031C     		mov	r3, r0
 527 0014 221C     		add	r2, r4, #0
 528 0016 1343     		orr	r3, r2
 529 0018 9BB2     		uxth	r3, r3
 530 001a 9BB2     		uxth	r3, r3
 647:.\Generated_Source\PSoC4/UART.c ****     #endif /* UART_RX_INTERRUPT_ENABLED */
 648:.\Generated_Source\PSoC4/UART.c ****         
 649:.\Generated_Source\PSoC4/UART.c ****     }
 531              		.loc 1 649 0
 532 001c 181C     		mov	r0, r3
 533 001e BD46     		mov	sp, r7
 534              		@ sp needed
 535 0020 98BD     		pop	{r3, r4, r7, pc}
 536              		.cfi_endproc
 537              	.LFE11:
 538              		.size	UART_GetByte, .-UART_GetByte
 539 0022 C046     		.section	.text.UART_GetRxBufferSize,"ax",%progbits
 540              		.align	2
 541              		.global	UART_GetRxBufferSize
 542              		.code	16
 543              		.thumb_func
 544              		.type	UART_GetRxBufferSize, %function
 545              	UART_GetRxBufferSize:
 546              	.LFB12:
 650:.\Generated_Source\PSoC4/UART.c **** 
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 22


 651:.\Generated_Source\PSoC4/UART.c **** 
 652:.\Generated_Source\PSoC4/UART.c ****     /*******************************************************************************
 653:.\Generated_Source\PSoC4/UART.c ****     * Function Name: UART_GetRxBufferSize
 654:.\Generated_Source\PSoC4/UART.c ****     ********************************************************************************
 655:.\Generated_Source\PSoC4/UART.c ****     *
 656:.\Generated_Source\PSoC4/UART.c ****     * Summary:
 657:.\Generated_Source\PSoC4/UART.c ****     *  Returns the number of received bytes available in the RX buffer.
 658:.\Generated_Source\PSoC4/UART.c ****     *  * RX software buffer is disabled (RX Buffer Size parameter is equal to 4): 
 659:.\Generated_Source\PSoC4/UART.c ****     *    returns 0 for empty RX FIFO or 1 for not empty RX FIFO.
 660:.\Generated_Source\PSoC4/UART.c ****     *  * RX software buffer is enabled: returns the number of bytes available in 
 661:.\Generated_Source\PSoC4/UART.c ****     *    the RX software buffer. Bytes available in the RX FIFO do not take to 
 662:.\Generated_Source\PSoC4/UART.c ****     *    account.
 663:.\Generated_Source\PSoC4/UART.c ****     *
 664:.\Generated_Source\PSoC4/UART.c ****     * Parameters:
 665:.\Generated_Source\PSoC4/UART.c ****     *  None.
 666:.\Generated_Source\PSoC4/UART.c ****     *
 667:.\Generated_Source\PSoC4/UART.c ****     * Return:
 668:.\Generated_Source\PSoC4/UART.c ****     *  uint8: Number of bytes in the RX buffer. 
 669:.\Generated_Source\PSoC4/UART.c ****     *    Return value type depends on RX Buffer Size parameter.
 670:.\Generated_Source\PSoC4/UART.c ****     *
 671:.\Generated_Source\PSoC4/UART.c ****     * Global Variables:
 672:.\Generated_Source\PSoC4/UART.c ****     *  UART_rxBufferWrite - used to calculate left bytes.
 673:.\Generated_Source\PSoC4/UART.c ****     *  UART_rxBufferRead - used to calculate left bytes.
 674:.\Generated_Source\PSoC4/UART.c ****     *  UART_rxBufferLoopDetect - checked to decide left bytes amount.
 675:.\Generated_Source\PSoC4/UART.c ****     *
 676:.\Generated_Source\PSoC4/UART.c ****     * Reentrant:
 677:.\Generated_Source\PSoC4/UART.c ****     *  No.
 678:.\Generated_Source\PSoC4/UART.c ****     *
 679:.\Generated_Source\PSoC4/UART.c ****     * Theory:
 680:.\Generated_Source\PSoC4/UART.c ****     *  Allows the user to find out how full the RX Buffer is.
 681:.\Generated_Source\PSoC4/UART.c ****     *
 682:.\Generated_Source\PSoC4/UART.c ****     *******************************************************************************/
 683:.\Generated_Source\PSoC4/UART.c ****     uint8 UART_GetRxBufferSize(void)
 684:.\Generated_Source\PSoC4/UART.c ****                                                             
 685:.\Generated_Source\PSoC4/UART.c ****     {
 547              		.loc 1 685 0
 548              		.cfi_startproc
 549 0000 80B5     		push	{r7, lr}
 550              		.cfi_def_cfa_offset 8
 551              		.cfi_offset 7, -8
 552              		.cfi_offset 14, -4
 553 0002 82B0     		sub	sp, sp, #8
 554              		.cfi_def_cfa_offset 16
 555 0004 00AF     		add	r7, sp, #0
 556              		.cfi_def_cfa_register 7
 686:.\Generated_Source\PSoC4/UART.c ****         uint8 size;
 687:.\Generated_Source\PSoC4/UART.c **** 
 688:.\Generated_Source\PSoC4/UART.c ****     #if (UART_RX_INTERRUPT_ENABLED)
 689:.\Generated_Source\PSoC4/UART.c **** 
 690:.\Generated_Source\PSoC4/UART.c ****         /* Protect variables that could change on interrupt */
 691:.\Generated_Source\PSoC4/UART.c ****         UART_DisableRxInt();
 692:.\Generated_Source\PSoC4/UART.c **** 
 693:.\Generated_Source\PSoC4/UART.c ****         if(UART_rxBufferRead == UART_rxBufferWrite)
 694:.\Generated_Source\PSoC4/UART.c ****         {
 695:.\Generated_Source\PSoC4/UART.c ****             if(UART_rxBufferLoopDetect != 0u)
 696:.\Generated_Source\PSoC4/UART.c ****             {
 697:.\Generated_Source\PSoC4/UART.c ****                 size = UART_RX_BUFFER_SIZE;
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 23


 698:.\Generated_Source\PSoC4/UART.c ****             }
 699:.\Generated_Source\PSoC4/UART.c ****             else
 700:.\Generated_Source\PSoC4/UART.c ****             {
 701:.\Generated_Source\PSoC4/UART.c ****                 size = 0u;
 702:.\Generated_Source\PSoC4/UART.c ****             }
 703:.\Generated_Source\PSoC4/UART.c ****         }
 704:.\Generated_Source\PSoC4/UART.c ****         else if(UART_rxBufferRead < UART_rxBufferWrite)
 705:.\Generated_Source\PSoC4/UART.c ****         {
 706:.\Generated_Source\PSoC4/UART.c ****             size = (UART_rxBufferWrite - UART_rxBufferRead);
 707:.\Generated_Source\PSoC4/UART.c ****         }
 708:.\Generated_Source\PSoC4/UART.c ****         else
 709:.\Generated_Source\PSoC4/UART.c ****         {
 710:.\Generated_Source\PSoC4/UART.c ****             size = (UART_RX_BUFFER_SIZE - UART_rxBufferRead) + UART_rxBufferWrite;
 711:.\Generated_Source\PSoC4/UART.c ****         }
 712:.\Generated_Source\PSoC4/UART.c **** 
 713:.\Generated_Source\PSoC4/UART.c ****         UART_EnableRxInt();
 714:.\Generated_Source\PSoC4/UART.c **** 
 715:.\Generated_Source\PSoC4/UART.c ****     #else
 716:.\Generated_Source\PSoC4/UART.c **** 
 717:.\Generated_Source\PSoC4/UART.c ****         /* We can only know if there is data in the fifo. */
 718:.\Generated_Source\PSoC4/UART.c ****         size = ((UART_RXSTATUS_REG & UART_RX_STS_FIFO_NOTEMPTY) != 0u) ? 1u : 0u;
 557              		.loc 1 718 0
 558 0006 094B     		ldr	r3, .L39
 559 0008 1B78     		ldrb	r3, [r3]
 560 000a DBB2     		uxtb	r3, r3
 561 000c 1A1C     		mov	r2, r3
 562 000e 2023     		mov	r3, #32
 563 0010 1340     		and	r3, r2
 564 0012 01D0     		beq	.L36
 565              		.loc 1 718 0 is_stmt 0 discriminator 1
 566 0014 0123     		mov	r3, #1
 567 0016 00E0     		b	.L37
 568              	.L36:
 569              		.loc 1 718 0 discriminator 2
 570 0018 0023     		mov	r3, #0
 571              	.L37:
 572              		.loc 1 718 0 discriminator 3
 573 001a FA1D     		add	r2, r7, #7
 574 001c 1370     		strb	r3, [r2]
 719:.\Generated_Source\PSoC4/UART.c **** 
 720:.\Generated_Source\PSoC4/UART.c ****     #endif /* (UART_RX_INTERRUPT_ENABLED) */
 721:.\Generated_Source\PSoC4/UART.c **** 
 722:.\Generated_Source\PSoC4/UART.c ****         return(size);
 575              		.loc 1 722 0 is_stmt 1 discriminator 3
 576 001e FB1D     		add	r3, r7, #7
 577 0020 1B78     		ldrb	r3, [r3]
 723:.\Generated_Source\PSoC4/UART.c ****     }
 578              		.loc 1 723 0 discriminator 3
 579 0022 181C     		mov	r0, r3
 580 0024 BD46     		mov	sp, r7
 581 0026 02B0     		add	sp, sp, #8
 582              		@ sp needed
 583 0028 80BD     		pop	{r7, pc}
 584              	.L40:
 585 002a C046     		.align	2
 586              	.L39:
 587 002c 60000F40 		.word	1074724960
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 24


 588              		.cfi_endproc
 589              	.LFE12:
 590              		.size	UART_GetRxBufferSize, .-UART_GetRxBufferSize
 591              		.section	.text.UART_ClearRxBuffer,"ax",%progbits
 592              		.align	2
 593              		.global	UART_ClearRxBuffer
 594              		.code	16
 595              		.thumb_func
 596              		.type	UART_ClearRxBuffer, %function
 597              	UART_ClearRxBuffer:
 598              	.LFB13:
 724:.\Generated_Source\PSoC4/UART.c **** 
 725:.\Generated_Source\PSoC4/UART.c **** 
 726:.\Generated_Source\PSoC4/UART.c ****     /*******************************************************************************
 727:.\Generated_Source\PSoC4/UART.c ****     * Function Name: UART_ClearRxBuffer
 728:.\Generated_Source\PSoC4/UART.c ****     ********************************************************************************
 729:.\Generated_Source\PSoC4/UART.c ****     *
 730:.\Generated_Source\PSoC4/UART.c ****     * Summary:
 731:.\Generated_Source\PSoC4/UART.c ****     *  Clears the receiver memory buffer and hardware RX FIFO of all received data.
 732:.\Generated_Source\PSoC4/UART.c ****     *
 733:.\Generated_Source\PSoC4/UART.c ****     * Parameters:
 734:.\Generated_Source\PSoC4/UART.c ****     *  None.
 735:.\Generated_Source\PSoC4/UART.c ****     *
 736:.\Generated_Source\PSoC4/UART.c ****     * Return:
 737:.\Generated_Source\PSoC4/UART.c ****     *  None.
 738:.\Generated_Source\PSoC4/UART.c ****     *
 739:.\Generated_Source\PSoC4/UART.c ****     * Global Variables:
 740:.\Generated_Source\PSoC4/UART.c ****     *  UART_rxBufferWrite - cleared to zero.
 741:.\Generated_Source\PSoC4/UART.c ****     *  UART_rxBufferRead - cleared to zero.
 742:.\Generated_Source\PSoC4/UART.c ****     *  UART_rxBufferLoopDetect - cleared to zero.
 743:.\Generated_Source\PSoC4/UART.c ****     *  UART_rxBufferOverflow - cleared to zero.
 744:.\Generated_Source\PSoC4/UART.c ****     *
 745:.\Generated_Source\PSoC4/UART.c ****     * Reentrant:
 746:.\Generated_Source\PSoC4/UART.c ****     *  No.
 747:.\Generated_Source\PSoC4/UART.c ****     *
 748:.\Generated_Source\PSoC4/UART.c ****     * Theory:
 749:.\Generated_Source\PSoC4/UART.c ****     *  Setting the pointers to zero makes the system believe there is no data to
 750:.\Generated_Source\PSoC4/UART.c ****     *  read and writing will resume at address 0 overwriting any data that may
 751:.\Generated_Source\PSoC4/UART.c ****     *  have remained in the RAM.
 752:.\Generated_Source\PSoC4/UART.c ****     *
 753:.\Generated_Source\PSoC4/UART.c ****     * Side Effects:
 754:.\Generated_Source\PSoC4/UART.c ****     *  Any received data not read from the RAM or FIFO buffer will be lost.
 755:.\Generated_Source\PSoC4/UART.c ****     *
 756:.\Generated_Source\PSoC4/UART.c ****     *******************************************************************************/
 757:.\Generated_Source\PSoC4/UART.c ****     void UART_ClearRxBuffer(void) 
 758:.\Generated_Source\PSoC4/UART.c ****     {
 599              		.loc 1 758 0
 600              		.cfi_startproc
 601 0000 90B5     		push	{r4, r7, lr}
 602              		.cfi_def_cfa_offset 12
 603              		.cfi_offset 4, -12
 604              		.cfi_offset 7, -8
 605              		.cfi_offset 14, -4
 606 0002 83B0     		sub	sp, sp, #12
 607              		.cfi_def_cfa_offset 24
 608 0004 00AF     		add	r7, sp, #0
 609              		.cfi_def_cfa_register 7
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 25


 759:.\Generated_Source\PSoC4/UART.c ****         uint8 enableInterrupts;
 760:.\Generated_Source\PSoC4/UART.c **** 
 761:.\Generated_Source\PSoC4/UART.c ****         /* Clear the HW FIFO */
 762:.\Generated_Source\PSoC4/UART.c ****         enableInterrupts = CyEnterCriticalSection();
 610              		.loc 1 762 0
 611 0006 FC1D     		add	r4, r7, #7
 612 0008 FFF7FEFF 		bl	CyEnterCriticalSection
 613 000c 031C     		mov	r3, r0
 614 000e 2370     		strb	r3, [r4]
 763:.\Generated_Source\PSoC4/UART.c ****         UART_RXDATA_AUX_CTL_REG |= (uint8)  UART_RX_FIFO_CLR;
 615              		.loc 1 763 0
 616 0010 0B4B     		ldr	r3, .L42
 617 0012 0B4A     		ldr	r2, .L42
 618 0014 1278     		ldrb	r2, [r2]
 619 0016 D2B2     		uxtb	r2, r2
 620 0018 0121     		mov	r1, #1
 621 001a 0A43     		orr	r2, r1
 622 001c D2B2     		uxtb	r2, r2
 623 001e 1A70     		strb	r2, [r3]
 764:.\Generated_Source\PSoC4/UART.c ****         UART_RXDATA_AUX_CTL_REG &= (uint8) ~UART_RX_FIFO_CLR;
 624              		.loc 1 764 0
 625 0020 074B     		ldr	r3, .L42
 626 0022 074A     		ldr	r2, .L42
 627 0024 1278     		ldrb	r2, [r2]
 628 0026 D2B2     		uxtb	r2, r2
 629 0028 0121     		mov	r1, #1
 630 002a 8A43     		bic	r2, r1
 631 002c D2B2     		uxtb	r2, r2
 632 002e 1A70     		strb	r2, [r3]
 765:.\Generated_Source\PSoC4/UART.c ****         CyExitCriticalSection(enableInterrupts);
 633              		.loc 1 765 0
 634 0030 FB1D     		add	r3, r7, #7
 635 0032 1B78     		ldrb	r3, [r3]
 636 0034 181C     		mov	r0, r3
 637 0036 FFF7FEFF 		bl	CyExitCriticalSection
 766:.\Generated_Source\PSoC4/UART.c **** 
 767:.\Generated_Source\PSoC4/UART.c ****     #if (UART_RX_INTERRUPT_ENABLED)
 768:.\Generated_Source\PSoC4/UART.c **** 
 769:.\Generated_Source\PSoC4/UART.c ****         /* Protect variables that could change on interrupt. */
 770:.\Generated_Source\PSoC4/UART.c ****         UART_DisableRxInt();
 771:.\Generated_Source\PSoC4/UART.c **** 
 772:.\Generated_Source\PSoC4/UART.c ****         UART_rxBufferRead = 0u;
 773:.\Generated_Source\PSoC4/UART.c ****         UART_rxBufferWrite = 0u;
 774:.\Generated_Source\PSoC4/UART.c ****         UART_rxBufferLoopDetect = 0u;
 775:.\Generated_Source\PSoC4/UART.c ****         UART_rxBufferOverflow = 0u;
 776:.\Generated_Source\PSoC4/UART.c **** 
 777:.\Generated_Source\PSoC4/UART.c ****         UART_EnableRxInt();
 778:.\Generated_Source\PSoC4/UART.c **** 
 779:.\Generated_Source\PSoC4/UART.c ****     #endif /* (UART_RX_INTERRUPT_ENABLED) */
 780:.\Generated_Source\PSoC4/UART.c **** 
 781:.\Generated_Source\PSoC4/UART.c ****     }
 638              		.loc 1 781 0
 639 003a BD46     		mov	sp, r7
 640 003c 03B0     		add	sp, sp, #12
 641              		@ sp needed
 642 003e 90BD     		pop	{r4, r7, pc}
 643              	.L43:
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 26


 644              		.align	2
 645              	.L42:
 646 0040 91000F40 		.word	1074725009
 647              		.cfi_endproc
 648              	.LFE13:
 649              		.size	UART_ClearRxBuffer, .-UART_ClearRxBuffer
 650              		.section	.text.UART_SetRxAddressMode,"ax",%progbits
 651              		.align	2
 652              		.global	UART_SetRxAddressMode
 653              		.code	16
 654              		.thumb_func
 655              		.type	UART_SetRxAddressMode, %function
 656              	UART_SetRxAddressMode:
 657              	.LFB14:
 782:.\Generated_Source\PSoC4/UART.c **** 
 783:.\Generated_Source\PSoC4/UART.c **** 
 784:.\Generated_Source\PSoC4/UART.c ****     /*******************************************************************************
 785:.\Generated_Source\PSoC4/UART.c ****     * Function Name: UART_SetRxAddressMode
 786:.\Generated_Source\PSoC4/UART.c ****     ********************************************************************************
 787:.\Generated_Source\PSoC4/UART.c ****     *
 788:.\Generated_Source\PSoC4/UART.c ****     * Summary:
 789:.\Generated_Source\PSoC4/UART.c ****     *  Sets the software controlled Addressing mode used by the RX portion of the
 790:.\Generated_Source\PSoC4/UART.c ****     *  UART.
 791:.\Generated_Source\PSoC4/UART.c ****     *
 792:.\Generated_Source\PSoC4/UART.c ****     * Parameters:
 793:.\Generated_Source\PSoC4/UART.c ****     *  addressMode: Enumerated value indicating the mode of RX addressing
 794:.\Generated_Source\PSoC4/UART.c ****     *  UART__B_UART__AM_SW_BYTE_BYTE -  Software Byte-by-Byte address
 795:.\Generated_Source\PSoC4/UART.c ****     *                                               detection
 796:.\Generated_Source\PSoC4/UART.c ****     *  UART__B_UART__AM_SW_DETECT_TO_BUFFER - Software Detect to Buffer
 797:.\Generated_Source\PSoC4/UART.c ****     *                                               address detection
 798:.\Generated_Source\PSoC4/UART.c ****     *  UART__B_UART__AM_HW_BYTE_BY_BYTE - Hardware Byte-by-Byte address
 799:.\Generated_Source\PSoC4/UART.c ****     *                                               detection
 800:.\Generated_Source\PSoC4/UART.c ****     *  UART__B_UART__AM_HW_DETECT_TO_BUFFER - Hardware Detect to Buffer
 801:.\Generated_Source\PSoC4/UART.c ****     *                                               address detection
 802:.\Generated_Source\PSoC4/UART.c ****     *  UART__B_UART__AM_NONE - No address detection
 803:.\Generated_Source\PSoC4/UART.c ****     *
 804:.\Generated_Source\PSoC4/UART.c ****     * Return:
 805:.\Generated_Source\PSoC4/UART.c ****     *  None.
 806:.\Generated_Source\PSoC4/UART.c ****     *
 807:.\Generated_Source\PSoC4/UART.c ****     * Global Variables:
 808:.\Generated_Source\PSoC4/UART.c ****     *  UART_rxAddressMode - the parameter stored in this variable for
 809:.\Generated_Source\PSoC4/UART.c ****     *   the farther usage in RX ISR.
 810:.\Generated_Source\PSoC4/UART.c ****     *  UART_rxAddressDetected - set to initial state (0).
 811:.\Generated_Source\PSoC4/UART.c ****     *
 812:.\Generated_Source\PSoC4/UART.c ****     *******************************************************************************/
 813:.\Generated_Source\PSoC4/UART.c ****     void UART_SetRxAddressMode(uint8 addressMode)
 814:.\Generated_Source\PSoC4/UART.c ****                                                         
 815:.\Generated_Source\PSoC4/UART.c ****     {
 658              		.loc 1 815 0
 659              		.cfi_startproc
 660 0000 80B5     		push	{r7, lr}
 661              		.cfi_def_cfa_offset 8
 662              		.cfi_offset 7, -8
 663              		.cfi_offset 14, -4
 664 0002 82B0     		sub	sp, sp, #8
 665              		.cfi_def_cfa_offset 16
 666 0004 00AF     		add	r7, sp, #0
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 27


 667              		.cfi_def_cfa_register 7
 668 0006 021C     		mov	r2, r0
 669 0008 FB1D     		add	r3, r7, #7
 670 000a 1A70     		strb	r2, [r3]
 816:.\Generated_Source\PSoC4/UART.c ****         #if(UART_RXHW_ADDRESS_ENABLED)
 817:.\Generated_Source\PSoC4/UART.c ****             #if(UART_CONTROL_REG_REMOVED)
 818:.\Generated_Source\PSoC4/UART.c ****                 if(0u != addressMode)
 819:.\Generated_Source\PSoC4/UART.c ****                 {
 820:.\Generated_Source\PSoC4/UART.c ****                     /* Suppress compiler warning */
 821:.\Generated_Source\PSoC4/UART.c ****                 }
 822:.\Generated_Source\PSoC4/UART.c ****             #else /* UART_CONTROL_REG_REMOVED */
 823:.\Generated_Source\PSoC4/UART.c ****                 uint8 tmpCtrl;
 824:.\Generated_Source\PSoC4/UART.c ****                 tmpCtrl = UART_CONTROL_REG & (uint8)~UART_CTRL_RXADDR_MODE_MASK;
 825:.\Generated_Source\PSoC4/UART.c ****                 tmpCtrl |= (uint8)(addressMode << UART_CTRL_RXADDR_MODE0_SHIFT);
 826:.\Generated_Source\PSoC4/UART.c ****                 UART_CONTROL_REG = tmpCtrl;
 827:.\Generated_Source\PSoC4/UART.c **** 
 828:.\Generated_Source\PSoC4/UART.c ****                 #if(UART_RX_INTERRUPT_ENABLED && \
 829:.\Generated_Source\PSoC4/UART.c ****                    (UART_RXBUFFERSIZE > UART_FIFO_LENGTH) )
 830:.\Generated_Source\PSoC4/UART.c ****                     UART_rxAddressMode = addressMode;
 831:.\Generated_Source\PSoC4/UART.c ****                     UART_rxAddressDetected = 0u;
 832:.\Generated_Source\PSoC4/UART.c ****                 #endif /* End UART_RXBUFFERSIZE > UART_FIFO_LENGTH*/
 833:.\Generated_Source\PSoC4/UART.c ****             #endif /* End UART_CONTROL_REG_REMOVED */
 834:.\Generated_Source\PSoC4/UART.c ****         #else /* UART_RXHW_ADDRESS_ENABLED */
 835:.\Generated_Source\PSoC4/UART.c ****             if(0u != addressMode)
 836:.\Generated_Source\PSoC4/UART.c ****             {
 837:.\Generated_Source\PSoC4/UART.c ****                 /* Suppress compiler warning */
 838:.\Generated_Source\PSoC4/UART.c ****             }
 839:.\Generated_Source\PSoC4/UART.c ****         #endif /* End UART_RXHW_ADDRESS_ENABLED */
 840:.\Generated_Source\PSoC4/UART.c ****     }
 671              		.loc 1 840 0
 672 000c BD46     		mov	sp, r7
 673 000e 02B0     		add	sp, sp, #8
 674              		@ sp needed
 675 0010 80BD     		pop	{r7, pc}
 676              		.cfi_endproc
 677              	.LFE14:
 678              		.size	UART_SetRxAddressMode, .-UART_SetRxAddressMode
 679 0012 C046     		.section	.text.UART_SetRxAddress1,"ax",%progbits
 680              		.align	2
 681              		.global	UART_SetRxAddress1
 682              		.code	16
 683              		.thumb_func
 684              		.type	UART_SetRxAddress1, %function
 685              	UART_SetRxAddress1:
 686              	.LFB15:
 841:.\Generated_Source\PSoC4/UART.c **** 
 842:.\Generated_Source\PSoC4/UART.c **** 
 843:.\Generated_Source\PSoC4/UART.c ****     /*******************************************************************************
 844:.\Generated_Source\PSoC4/UART.c ****     * Function Name: UART_SetRxAddress1
 845:.\Generated_Source\PSoC4/UART.c ****     ********************************************************************************
 846:.\Generated_Source\PSoC4/UART.c ****     *
 847:.\Generated_Source\PSoC4/UART.c ****     * Summary:
 848:.\Generated_Source\PSoC4/UART.c ****     *  Sets the first of two hardware-detectable receiver addresses.
 849:.\Generated_Source\PSoC4/UART.c ****     *
 850:.\Generated_Source\PSoC4/UART.c ****     * Parameters:
 851:.\Generated_Source\PSoC4/UART.c ****     *  address: Address #1 for hardware address detection.
 852:.\Generated_Source\PSoC4/UART.c ****     *
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 28


 853:.\Generated_Source\PSoC4/UART.c ****     * Return:
 854:.\Generated_Source\PSoC4/UART.c ****     *  None.
 855:.\Generated_Source\PSoC4/UART.c ****     *
 856:.\Generated_Source\PSoC4/UART.c ****     *******************************************************************************/
 857:.\Generated_Source\PSoC4/UART.c ****     void UART_SetRxAddress1(uint8 address) 
 858:.\Generated_Source\PSoC4/UART.c ****     {
 687              		.loc 1 858 0
 688              		.cfi_startproc
 689 0000 80B5     		push	{r7, lr}
 690              		.cfi_def_cfa_offset 8
 691              		.cfi_offset 7, -8
 692              		.cfi_offset 14, -4
 693 0002 82B0     		sub	sp, sp, #8
 694              		.cfi_def_cfa_offset 16
 695 0004 00AF     		add	r7, sp, #0
 696              		.cfi_def_cfa_register 7
 697 0006 021C     		mov	r2, r0
 698 0008 FB1D     		add	r3, r7, #7
 699 000a 1A70     		strb	r2, [r3]
 859:.\Generated_Source\PSoC4/UART.c ****         UART_RXADDRESS1_REG = address;
 700              		.loc 1 859 0
 701 000c 034B     		ldr	r3, .L46
 702 000e FA1D     		add	r2, r7, #7
 703 0010 1278     		ldrb	r2, [r2]
 704 0012 1A70     		strb	r2, [r3]
 860:.\Generated_Source\PSoC4/UART.c ****     }
 705              		.loc 1 860 0
 706 0014 BD46     		mov	sp, r7
 707 0016 02B0     		add	sp, sp, #8
 708              		@ sp needed
 709 0018 80BD     		pop	{r7, pc}
 710              	.L47:
 711 001a C046     		.align	2
 712              	.L46:
 713 001c 21000F40 		.word	1074724897
 714              		.cfi_endproc
 715              	.LFE15:
 716              		.size	UART_SetRxAddress1, .-UART_SetRxAddress1
 717              		.section	.text.UART_SetRxAddress2,"ax",%progbits
 718              		.align	2
 719              		.global	UART_SetRxAddress2
 720              		.code	16
 721              		.thumb_func
 722              		.type	UART_SetRxAddress2, %function
 723              	UART_SetRxAddress2:
 724              	.LFB16:
 861:.\Generated_Source\PSoC4/UART.c **** 
 862:.\Generated_Source\PSoC4/UART.c **** 
 863:.\Generated_Source\PSoC4/UART.c ****     /*******************************************************************************
 864:.\Generated_Source\PSoC4/UART.c ****     * Function Name: UART_SetRxAddress2
 865:.\Generated_Source\PSoC4/UART.c ****     ********************************************************************************
 866:.\Generated_Source\PSoC4/UART.c ****     *
 867:.\Generated_Source\PSoC4/UART.c ****     * Summary:
 868:.\Generated_Source\PSoC4/UART.c ****     *  Sets the second of two hardware-detectable receiver addresses.
 869:.\Generated_Source\PSoC4/UART.c ****     *
 870:.\Generated_Source\PSoC4/UART.c ****     * Parameters:
 871:.\Generated_Source\PSoC4/UART.c ****     *  address: Address #2 for hardware address detection.
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 29


 872:.\Generated_Source\PSoC4/UART.c ****     *
 873:.\Generated_Source\PSoC4/UART.c ****     * Return:
 874:.\Generated_Source\PSoC4/UART.c ****     *  None.
 875:.\Generated_Source\PSoC4/UART.c ****     *
 876:.\Generated_Source\PSoC4/UART.c ****     *******************************************************************************/
 877:.\Generated_Source\PSoC4/UART.c ****     void UART_SetRxAddress2(uint8 address) 
 878:.\Generated_Source\PSoC4/UART.c ****     {
 725              		.loc 1 878 0
 726              		.cfi_startproc
 727 0000 80B5     		push	{r7, lr}
 728              		.cfi_def_cfa_offset 8
 729              		.cfi_offset 7, -8
 730              		.cfi_offset 14, -4
 731 0002 82B0     		sub	sp, sp, #8
 732              		.cfi_def_cfa_offset 16
 733 0004 00AF     		add	r7, sp, #0
 734              		.cfi_def_cfa_register 7
 735 0006 021C     		mov	r2, r0
 736 0008 FB1D     		add	r3, r7, #7
 737 000a 1A70     		strb	r2, [r3]
 879:.\Generated_Source\PSoC4/UART.c ****         UART_RXADDRESS2_REG = address;
 738              		.loc 1 879 0
 739 000c 034B     		ldr	r3, .L49
 740 000e FA1D     		add	r2, r7, #7
 741 0010 1278     		ldrb	r2, [r2]
 742 0012 1A70     		strb	r2, [r3]
 880:.\Generated_Source\PSoC4/UART.c ****     }
 743              		.loc 1 880 0
 744 0014 BD46     		mov	sp, r7
 745 0016 02B0     		add	sp, sp, #8
 746              		@ sp needed
 747 0018 80BD     		pop	{r7, pc}
 748              	.L50:
 749 001a C046     		.align	2
 750              	.L49:
 751 001c 31000F40 		.word	1074724913
 752              		.cfi_endproc
 753              	.LFE16:
 754              		.size	UART_SetRxAddress2, .-UART_SetRxAddress2
 755              		.section	.text.UART_SetTxInterruptMode,"ax",%progbits
 756              		.align	2
 757              		.global	UART_SetTxInterruptMode
 758              		.code	16
 759              		.thumb_func
 760              		.type	UART_SetTxInterruptMode, %function
 761              	UART_SetTxInterruptMode:
 762              	.LFB17:
 881:.\Generated_Source\PSoC4/UART.c **** 
 882:.\Generated_Source\PSoC4/UART.c **** #endif  /* UART_RX_ENABLED || UART_HD_ENABLED*/
 883:.\Generated_Source\PSoC4/UART.c **** 
 884:.\Generated_Source\PSoC4/UART.c **** 
 885:.\Generated_Source\PSoC4/UART.c **** #if( (UART_TX_ENABLED) || (UART_HD_ENABLED) )
 886:.\Generated_Source\PSoC4/UART.c ****     /*******************************************************************************
 887:.\Generated_Source\PSoC4/UART.c ****     * Function Name: UART_SetTxInterruptMode
 888:.\Generated_Source\PSoC4/UART.c ****     ********************************************************************************
 889:.\Generated_Source\PSoC4/UART.c ****     *
 890:.\Generated_Source\PSoC4/UART.c ****     * Summary:
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 30


 891:.\Generated_Source\PSoC4/UART.c ****     *  Configures the TX interrupt sources to be enabled, but does not enable the
 892:.\Generated_Source\PSoC4/UART.c ****     *  interrupt.
 893:.\Generated_Source\PSoC4/UART.c ****     *
 894:.\Generated_Source\PSoC4/UART.c ****     * Parameters:
 895:.\Generated_Source\PSoC4/UART.c ****     *  intSrc: Bit field containing the TX interrupt sources to enable
 896:.\Generated_Source\PSoC4/UART.c ****     *   UART_TX_STS_COMPLETE        Interrupt on TX byte complete
 897:.\Generated_Source\PSoC4/UART.c ****     *   UART_TX_STS_FIFO_EMPTY      Interrupt when TX FIFO is empty
 898:.\Generated_Source\PSoC4/UART.c ****     *   UART_TX_STS_FIFO_FULL       Interrupt when TX FIFO is full
 899:.\Generated_Source\PSoC4/UART.c ****     *   UART_TX_STS_FIFO_NOT_FULL   Interrupt when TX FIFO is not full
 900:.\Generated_Source\PSoC4/UART.c ****     *
 901:.\Generated_Source\PSoC4/UART.c ****     * Return:
 902:.\Generated_Source\PSoC4/UART.c ****     *  None.
 903:.\Generated_Source\PSoC4/UART.c ****     *
 904:.\Generated_Source\PSoC4/UART.c ****     * Theory:
 905:.\Generated_Source\PSoC4/UART.c ****     *  Enables the output of specific status bits to the interrupt controller
 906:.\Generated_Source\PSoC4/UART.c ****     *
 907:.\Generated_Source\PSoC4/UART.c ****     *******************************************************************************/
 908:.\Generated_Source\PSoC4/UART.c ****     void UART_SetTxInterruptMode(uint8 intSrc) 
 909:.\Generated_Source\PSoC4/UART.c ****     {
 763              		.loc 1 909 0
 764              		.cfi_startproc
 765 0000 80B5     		push	{r7, lr}
 766              		.cfi_def_cfa_offset 8
 767              		.cfi_offset 7, -8
 768              		.cfi_offset 14, -4
 769 0002 82B0     		sub	sp, sp, #8
 770              		.cfi_def_cfa_offset 16
 771 0004 00AF     		add	r7, sp, #0
 772              		.cfi_def_cfa_register 7
 773 0006 021C     		mov	r2, r0
 774 0008 FB1D     		add	r3, r7, #7
 775 000a 1A70     		strb	r2, [r3]
 910:.\Generated_Source\PSoC4/UART.c ****         UART_TXSTATUS_MASK_REG = intSrc;
 776              		.loc 1 910 0
 777 000c 034B     		ldr	r3, .L52
 778 000e FA1D     		add	r2, r7, #7
 779 0010 1278     		ldrb	r2, [r2]
 780 0012 1A70     		strb	r2, [r3]
 911:.\Generated_Source\PSoC4/UART.c ****     }
 781              		.loc 1 911 0
 782 0014 BD46     		mov	sp, r7
 783 0016 02B0     		add	sp, sp, #8
 784              		@ sp needed
 785 0018 80BD     		pop	{r7, pc}
 786              	.L53:
 787 001a C046     		.align	2
 788              	.L52:
 789 001c 82000F40 		.word	1074724994
 790              		.cfi_endproc
 791              	.LFE17:
 792              		.size	UART_SetTxInterruptMode, .-UART_SetTxInterruptMode
 793              		.section	.text.UART_WriteTxData,"ax",%progbits
 794              		.align	2
 795              		.global	UART_WriteTxData
 796              		.code	16
 797              		.thumb_func
 798              		.type	UART_WriteTxData, %function
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 31


 799              	UART_WriteTxData:
 800              	.LFB18:
 912:.\Generated_Source\PSoC4/UART.c **** 
 913:.\Generated_Source\PSoC4/UART.c **** 
 914:.\Generated_Source\PSoC4/UART.c ****     /*******************************************************************************
 915:.\Generated_Source\PSoC4/UART.c ****     * Function Name: UART_WriteTxData
 916:.\Generated_Source\PSoC4/UART.c ****     ********************************************************************************
 917:.\Generated_Source\PSoC4/UART.c ****     *
 918:.\Generated_Source\PSoC4/UART.c ****     * Summary:
 919:.\Generated_Source\PSoC4/UART.c ****     *  Places a byte of data into the transmit buffer to be sent when the bus is
 920:.\Generated_Source\PSoC4/UART.c ****     *  available without checking the TX status register. You must check status
 921:.\Generated_Source\PSoC4/UART.c ****     *  separately.
 922:.\Generated_Source\PSoC4/UART.c ****     *
 923:.\Generated_Source\PSoC4/UART.c ****     * Parameters:
 924:.\Generated_Source\PSoC4/UART.c ****     *  txDataByte: data byte
 925:.\Generated_Source\PSoC4/UART.c ****     *
 926:.\Generated_Source\PSoC4/UART.c ****     * Return:
 927:.\Generated_Source\PSoC4/UART.c ****     * None.
 928:.\Generated_Source\PSoC4/UART.c ****     *
 929:.\Generated_Source\PSoC4/UART.c ****     * Global Variables:
 930:.\Generated_Source\PSoC4/UART.c ****     *  UART_txBuffer - RAM buffer pointer for save data for transmission
 931:.\Generated_Source\PSoC4/UART.c ****     *  UART_txBufferWrite - cyclic index for write to txBuffer,
 932:.\Generated_Source\PSoC4/UART.c ****     *    incremented after each byte saved to buffer.
 933:.\Generated_Source\PSoC4/UART.c ****     *  UART_txBufferRead - cyclic index for read from txBuffer,
 934:.\Generated_Source\PSoC4/UART.c ****     *    checked to identify the condition to write to FIFO directly or to TX buffer
 935:.\Generated_Source\PSoC4/UART.c ****     *  UART_initVar - checked to identify that the component has been
 936:.\Generated_Source\PSoC4/UART.c ****     *    initialized.
 937:.\Generated_Source\PSoC4/UART.c ****     *
 938:.\Generated_Source\PSoC4/UART.c ****     * Reentrant:
 939:.\Generated_Source\PSoC4/UART.c ****     *  No.
 940:.\Generated_Source\PSoC4/UART.c ****     *
 941:.\Generated_Source\PSoC4/UART.c ****     *******************************************************************************/
 942:.\Generated_Source\PSoC4/UART.c ****     void UART_WriteTxData(uint8 txDataByte) 
 943:.\Generated_Source\PSoC4/UART.c ****     {
 801              		.loc 1 943 0
 802              		.cfi_startproc
 803 0000 80B5     		push	{r7, lr}
 804              		.cfi_def_cfa_offset 8
 805              		.cfi_offset 7, -8
 806              		.cfi_offset 14, -4
 807 0002 82B0     		sub	sp, sp, #8
 808              		.cfi_def_cfa_offset 16
 809 0004 00AF     		add	r7, sp, #0
 810              		.cfi_def_cfa_register 7
 811 0006 021C     		mov	r2, r0
 812 0008 FB1D     		add	r3, r7, #7
 813 000a 1A70     		strb	r2, [r3]
 944:.\Generated_Source\PSoC4/UART.c ****         /* If not Initialized then skip this function*/
 945:.\Generated_Source\PSoC4/UART.c ****         if(UART_initVar != 0u)
 814              		.loc 1 945 0
 815 000c 054B     		ldr	r3, .L56
 816 000e 1B78     		ldrb	r3, [r3]
 817 0010 002B     		cmp	r3, #0
 818 0012 03D0     		beq	.L54
 946:.\Generated_Source\PSoC4/UART.c ****         {
 947:.\Generated_Source\PSoC4/UART.c ****         #if (UART_TX_INTERRUPT_ENABLED)
 948:.\Generated_Source\PSoC4/UART.c **** 
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 32


 949:.\Generated_Source\PSoC4/UART.c ****             /* Protect variables that could change on interrupt. */
 950:.\Generated_Source\PSoC4/UART.c ****             UART_DisableTxInt();
 951:.\Generated_Source\PSoC4/UART.c **** 
 952:.\Generated_Source\PSoC4/UART.c ****             if( (UART_txBufferRead == UART_txBufferWrite) &&
 953:.\Generated_Source\PSoC4/UART.c ****                 ((UART_TXSTATUS_REG & UART_TX_STS_FIFO_FULL) == 0u) )
 954:.\Generated_Source\PSoC4/UART.c ****             {
 955:.\Generated_Source\PSoC4/UART.c ****                 /* Add directly to the FIFO. */
 956:.\Generated_Source\PSoC4/UART.c ****                 UART_TXDATA_REG = txDataByte;
 957:.\Generated_Source\PSoC4/UART.c ****             }
 958:.\Generated_Source\PSoC4/UART.c ****             else
 959:.\Generated_Source\PSoC4/UART.c ****             {
 960:.\Generated_Source\PSoC4/UART.c ****                 if(UART_txBufferWrite >= UART_TX_BUFFER_SIZE)
 961:.\Generated_Source\PSoC4/UART.c ****                 {
 962:.\Generated_Source\PSoC4/UART.c ****                     UART_txBufferWrite = 0u;
 963:.\Generated_Source\PSoC4/UART.c ****                 }
 964:.\Generated_Source\PSoC4/UART.c **** 
 965:.\Generated_Source\PSoC4/UART.c ****                 UART_txBuffer[UART_txBufferWrite] = txDataByte;
 966:.\Generated_Source\PSoC4/UART.c **** 
 967:.\Generated_Source\PSoC4/UART.c ****                 /* Add to the software buffer. */
 968:.\Generated_Source\PSoC4/UART.c ****                 UART_txBufferWrite++;
 969:.\Generated_Source\PSoC4/UART.c ****             }
 970:.\Generated_Source\PSoC4/UART.c **** 
 971:.\Generated_Source\PSoC4/UART.c ****             UART_EnableTxInt();
 972:.\Generated_Source\PSoC4/UART.c **** 
 973:.\Generated_Source\PSoC4/UART.c ****         #else
 974:.\Generated_Source\PSoC4/UART.c **** 
 975:.\Generated_Source\PSoC4/UART.c ****             /* Add directly to the FIFO. */
 976:.\Generated_Source\PSoC4/UART.c ****             UART_TXDATA_REG = txDataByte;
 819              		.loc 1 976 0
 820 0014 044B     		ldr	r3, .L56+4
 821 0016 FA1D     		add	r2, r7, #7
 822 0018 1278     		ldrb	r2, [r2]
 823 001a 1A70     		strb	r2, [r3]
 824              	.L54:
 977:.\Generated_Source\PSoC4/UART.c **** 
 978:.\Generated_Source\PSoC4/UART.c ****         #endif /*(UART_TX_INTERRUPT_ENABLED) */
 979:.\Generated_Source\PSoC4/UART.c ****         }
 980:.\Generated_Source\PSoC4/UART.c ****     }
 825              		.loc 1 980 0
 826 001c BD46     		mov	sp, r7
 827 001e 02B0     		add	sp, sp, #8
 828              		@ sp needed
 829 0020 80BD     		pop	{r7, pc}
 830              	.L57:
 831 0022 C046     		.align	2
 832              	.L56:
 833 0024 00000000 		.word	UART_initVar
 834 0028 42000F40 		.word	1074724930
 835              		.cfi_endproc
 836              	.LFE18:
 837              		.size	UART_WriteTxData, .-UART_WriteTxData
 838              		.section	.text.UART_ReadTxStatus,"ax",%progbits
 839              		.align	2
 840              		.global	UART_ReadTxStatus
 841              		.code	16
 842              		.thumb_func
 843              		.type	UART_ReadTxStatus, %function
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 33


 844              	UART_ReadTxStatus:
 845              	.LFB19:
 981:.\Generated_Source\PSoC4/UART.c **** 
 982:.\Generated_Source\PSoC4/UART.c **** 
 983:.\Generated_Source\PSoC4/UART.c ****     /*******************************************************************************
 984:.\Generated_Source\PSoC4/UART.c ****     * Function Name: UART_ReadTxStatus
 985:.\Generated_Source\PSoC4/UART.c ****     ********************************************************************************
 986:.\Generated_Source\PSoC4/UART.c ****     *
 987:.\Generated_Source\PSoC4/UART.c ****     * Summary:
 988:.\Generated_Source\PSoC4/UART.c ****     *  Reads the status register for the TX portion of the UART.
 989:.\Generated_Source\PSoC4/UART.c ****     *
 990:.\Generated_Source\PSoC4/UART.c ****     * Parameters:
 991:.\Generated_Source\PSoC4/UART.c ****     *  None.
 992:.\Generated_Source\PSoC4/UART.c ****     *
 993:.\Generated_Source\PSoC4/UART.c ****     * Return:
 994:.\Generated_Source\PSoC4/UART.c ****     *  Contents of the status register
 995:.\Generated_Source\PSoC4/UART.c ****     *
 996:.\Generated_Source\PSoC4/UART.c ****     * Theory:
 997:.\Generated_Source\PSoC4/UART.c ****     *  This function reads the TX status register, which is cleared on read.
 998:.\Generated_Source\PSoC4/UART.c ****     *  It is up to the user to handle all bits in this return value accordingly,
 999:.\Generated_Source\PSoC4/UART.c ****     *  even if the bit was not enabled as an interrupt source the event happened
1000:.\Generated_Source\PSoC4/UART.c ****     *  and must be handled accordingly.
1001:.\Generated_Source\PSoC4/UART.c ****     *
1002:.\Generated_Source\PSoC4/UART.c ****     *******************************************************************************/
1003:.\Generated_Source\PSoC4/UART.c ****     uint8 UART_ReadTxStatus(void) 
1004:.\Generated_Source\PSoC4/UART.c ****     {
 846              		.loc 1 1004 0
 847              		.cfi_startproc
 848 0000 80B5     		push	{r7, lr}
 849              		.cfi_def_cfa_offset 8
 850              		.cfi_offset 7, -8
 851              		.cfi_offset 14, -4
 852 0002 00AF     		add	r7, sp, #0
 853              		.cfi_def_cfa_register 7
1005:.\Generated_Source\PSoC4/UART.c ****         return(UART_TXSTATUS_REG);
 854              		.loc 1 1005 0
 855 0004 024B     		ldr	r3, .L60
 856 0006 1B78     		ldrb	r3, [r3]
 857 0008 DBB2     		uxtb	r3, r3
1006:.\Generated_Source\PSoC4/UART.c ****     }
 858              		.loc 1 1006 0
 859 000a 181C     		mov	r0, r3
 860 000c BD46     		mov	sp, r7
 861              		@ sp needed
 862 000e 80BD     		pop	{r7, pc}
 863              	.L61:
 864              		.align	2
 865              	.L60:
 866 0010 62000F40 		.word	1074724962
 867              		.cfi_endproc
 868              	.LFE19:
 869              		.size	UART_ReadTxStatus, .-UART_ReadTxStatus
 870              		.section	.text.UART_PutChar,"ax",%progbits
 871              		.align	2
 872              		.global	UART_PutChar
 873              		.code	16
 874              		.thumb_func
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 34


 875              		.type	UART_PutChar, %function
 876              	UART_PutChar:
 877              	.LFB20:
1007:.\Generated_Source\PSoC4/UART.c **** 
1008:.\Generated_Source\PSoC4/UART.c **** 
1009:.\Generated_Source\PSoC4/UART.c ****     /*******************************************************************************
1010:.\Generated_Source\PSoC4/UART.c ****     * Function Name: UART_PutChar
1011:.\Generated_Source\PSoC4/UART.c ****     ********************************************************************************
1012:.\Generated_Source\PSoC4/UART.c ****     *
1013:.\Generated_Source\PSoC4/UART.c ****     * Summary:
1014:.\Generated_Source\PSoC4/UART.c ****     *  Puts a byte of data into the transmit buffer to be sent when the bus is
1015:.\Generated_Source\PSoC4/UART.c ****     *  available. This is a blocking API that waits until the TX buffer has room to
1016:.\Generated_Source\PSoC4/UART.c ****     *  hold the data.
1017:.\Generated_Source\PSoC4/UART.c ****     *
1018:.\Generated_Source\PSoC4/UART.c ****     * Parameters:
1019:.\Generated_Source\PSoC4/UART.c ****     *  txDataByte: Byte containing the data to transmit
1020:.\Generated_Source\PSoC4/UART.c ****     *
1021:.\Generated_Source\PSoC4/UART.c ****     * Return:
1022:.\Generated_Source\PSoC4/UART.c ****     *  None.
1023:.\Generated_Source\PSoC4/UART.c ****     *
1024:.\Generated_Source\PSoC4/UART.c ****     * Global Variables:
1025:.\Generated_Source\PSoC4/UART.c ****     *  UART_txBuffer - RAM buffer pointer for save data for transmission
1026:.\Generated_Source\PSoC4/UART.c ****     *  UART_txBufferWrite - cyclic index for write to txBuffer,
1027:.\Generated_Source\PSoC4/UART.c ****     *     checked to identify free space in txBuffer and incremented after each byte
1028:.\Generated_Source\PSoC4/UART.c ****     *     saved to buffer.
1029:.\Generated_Source\PSoC4/UART.c ****     *  UART_txBufferRead - cyclic index for read from txBuffer,
1030:.\Generated_Source\PSoC4/UART.c ****     *     checked to identify free space in txBuffer.
1031:.\Generated_Source\PSoC4/UART.c ****     *  UART_initVar - checked to identify that the component has been
1032:.\Generated_Source\PSoC4/UART.c ****     *     initialized.
1033:.\Generated_Source\PSoC4/UART.c ****     *
1034:.\Generated_Source\PSoC4/UART.c ****     * Reentrant:
1035:.\Generated_Source\PSoC4/UART.c ****     *  No.
1036:.\Generated_Source\PSoC4/UART.c ****     *
1037:.\Generated_Source\PSoC4/UART.c ****     * Theory:
1038:.\Generated_Source\PSoC4/UART.c ****     *  Allows the user to transmit any byte of data in a single transfer
1039:.\Generated_Source\PSoC4/UART.c ****     *
1040:.\Generated_Source\PSoC4/UART.c ****     *******************************************************************************/
1041:.\Generated_Source\PSoC4/UART.c ****     void UART_PutChar(uint8 txDataByte) 
1042:.\Generated_Source\PSoC4/UART.c ****     {
 878              		.loc 1 1042 0
 879              		.cfi_startproc
 880 0000 80B5     		push	{r7, lr}
 881              		.cfi_def_cfa_offset 8
 882              		.cfi_offset 7, -8
 883              		.cfi_offset 14, -4
 884 0002 82B0     		sub	sp, sp, #8
 885              		.cfi_def_cfa_offset 16
 886 0004 00AF     		add	r7, sp, #0
 887              		.cfi_def_cfa_register 7
 888 0006 021C     		mov	r2, r0
 889 0008 FB1D     		add	r3, r7, #7
 890 000a 1A70     		strb	r2, [r3]
1043:.\Generated_Source\PSoC4/UART.c ****     #if (UART_TX_INTERRUPT_ENABLED)
1044:.\Generated_Source\PSoC4/UART.c ****         /* The temporary output pointer is used since it takes two instructions
1045:.\Generated_Source\PSoC4/UART.c ****         *  to increment with a wrap, and we can't risk doing that with the real
1046:.\Generated_Source\PSoC4/UART.c ****         *  pointer and getting an interrupt in between instructions.
1047:.\Generated_Source\PSoC4/UART.c ****         */
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 35


1048:.\Generated_Source\PSoC4/UART.c ****         uint8 locTxBufferWrite;
1049:.\Generated_Source\PSoC4/UART.c ****         uint8 locTxBufferRead;
1050:.\Generated_Source\PSoC4/UART.c **** 
1051:.\Generated_Source\PSoC4/UART.c ****         do
1052:.\Generated_Source\PSoC4/UART.c ****         { /* Block if software buffer is full, so we don't overwrite. */
1053:.\Generated_Source\PSoC4/UART.c **** 
1054:.\Generated_Source\PSoC4/UART.c ****         #if ((UART_TX_BUFFER_SIZE > UART_MAX_BYTE_VALUE) && (CY_PSOC3))
1055:.\Generated_Source\PSoC4/UART.c ****             /* Disable TX interrupt to protect variables from modification */
1056:.\Generated_Source\PSoC4/UART.c ****             UART_DisableTxInt();
1057:.\Generated_Source\PSoC4/UART.c ****         #endif /* (UART_TX_BUFFER_SIZE > UART_MAX_BYTE_VALUE) && (CY_PSOC3) */
1058:.\Generated_Source\PSoC4/UART.c **** 
1059:.\Generated_Source\PSoC4/UART.c ****             locTxBufferWrite = UART_txBufferWrite;
1060:.\Generated_Source\PSoC4/UART.c ****             locTxBufferRead  = UART_txBufferRead;
1061:.\Generated_Source\PSoC4/UART.c **** 
1062:.\Generated_Source\PSoC4/UART.c ****         #if ((UART_TX_BUFFER_SIZE > UART_MAX_BYTE_VALUE) && (CY_PSOC3))
1063:.\Generated_Source\PSoC4/UART.c ****             /* Enable interrupt to continue transmission */
1064:.\Generated_Source\PSoC4/UART.c ****             UART_EnableTxInt();
1065:.\Generated_Source\PSoC4/UART.c ****         #endif /* (UART_TX_BUFFER_SIZE > UART_MAX_BYTE_VALUE) && (CY_PSOC3) */
1066:.\Generated_Source\PSoC4/UART.c ****         }
1067:.\Generated_Source\PSoC4/UART.c ****         while( (locTxBufferWrite < locTxBufferRead) ? (locTxBufferWrite == (locTxBufferRead - 1u)) 
1068:.\Generated_Source\PSoC4/UART.c ****                                 ((locTxBufferWrite - locTxBufferRead) ==
1069:.\Generated_Source\PSoC4/UART.c ****                                 (uint8)(UART_TX_BUFFER_SIZE - 1u)) );
1070:.\Generated_Source\PSoC4/UART.c **** 
1071:.\Generated_Source\PSoC4/UART.c ****         if( (locTxBufferRead == locTxBufferWrite) &&
1072:.\Generated_Source\PSoC4/UART.c ****             ((UART_TXSTATUS_REG & UART_TX_STS_FIFO_FULL) == 0u) )
1073:.\Generated_Source\PSoC4/UART.c ****         {
1074:.\Generated_Source\PSoC4/UART.c ****             /* Add directly to the FIFO */
1075:.\Generated_Source\PSoC4/UART.c ****             UART_TXDATA_REG = txDataByte;
1076:.\Generated_Source\PSoC4/UART.c ****         }
1077:.\Generated_Source\PSoC4/UART.c ****         else
1078:.\Generated_Source\PSoC4/UART.c ****         {
1079:.\Generated_Source\PSoC4/UART.c ****             if(locTxBufferWrite >= UART_TX_BUFFER_SIZE)
1080:.\Generated_Source\PSoC4/UART.c ****             {
1081:.\Generated_Source\PSoC4/UART.c ****                 locTxBufferWrite = 0u;
1082:.\Generated_Source\PSoC4/UART.c ****             }
1083:.\Generated_Source\PSoC4/UART.c ****             /* Add to the software buffer. */
1084:.\Generated_Source\PSoC4/UART.c ****             UART_txBuffer[locTxBufferWrite] = txDataByte;
1085:.\Generated_Source\PSoC4/UART.c ****             locTxBufferWrite++;
1086:.\Generated_Source\PSoC4/UART.c **** 
1087:.\Generated_Source\PSoC4/UART.c ****             /* Finally, update the real output pointer */
1088:.\Generated_Source\PSoC4/UART.c ****         #if ((UART_TX_BUFFER_SIZE > UART_MAX_BYTE_VALUE) && (CY_PSOC3))
1089:.\Generated_Source\PSoC4/UART.c ****             UART_DisableTxInt();
1090:.\Generated_Source\PSoC4/UART.c ****         #endif /* (UART_TX_BUFFER_SIZE > UART_MAX_BYTE_VALUE) && (CY_PSOC3) */
1091:.\Generated_Source\PSoC4/UART.c **** 
1092:.\Generated_Source\PSoC4/UART.c ****             UART_txBufferWrite = locTxBufferWrite;
1093:.\Generated_Source\PSoC4/UART.c **** 
1094:.\Generated_Source\PSoC4/UART.c ****         #if ((UART_TX_BUFFER_SIZE > UART_MAX_BYTE_VALUE) && (CY_PSOC3))
1095:.\Generated_Source\PSoC4/UART.c ****             UART_EnableTxInt();
1096:.\Generated_Source\PSoC4/UART.c ****         #endif /* (UART_TX_BUFFER_SIZE > UART_MAX_BYTE_VALUE) && (CY_PSOC3) */
1097:.\Generated_Source\PSoC4/UART.c **** 
1098:.\Generated_Source\PSoC4/UART.c ****             if(0u != (UART_TXSTATUS_REG & UART_TX_STS_FIFO_EMPTY))
1099:.\Generated_Source\PSoC4/UART.c ****             {
1100:.\Generated_Source\PSoC4/UART.c ****                 /* Trigger TX interrupt to send software buffer */
1101:.\Generated_Source\PSoC4/UART.c ****                 UART_SetPendingTxInt();
1102:.\Generated_Source\PSoC4/UART.c ****             }
1103:.\Generated_Source\PSoC4/UART.c ****         }
1104:.\Generated_Source\PSoC4/UART.c **** 
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 36


1105:.\Generated_Source\PSoC4/UART.c ****     #else
1106:.\Generated_Source\PSoC4/UART.c **** 
1107:.\Generated_Source\PSoC4/UART.c ****         while((UART_TXSTATUS_REG & UART_TX_STS_FIFO_FULL) != 0u)
 891              		.loc 1 1107 0
 892 000c C046     		mov	r8, r8
 893              	.L63:
 894              		.loc 1 1107 0 is_stmt 0 discriminator 1
 895 000e 074B     		ldr	r3, .L64
 896 0010 1B78     		ldrb	r3, [r3]
 897 0012 DBB2     		uxtb	r3, r3
 898 0014 1A1C     		mov	r2, r3
 899 0016 0423     		mov	r3, #4
 900 0018 1340     		and	r3, r2
 901 001a F8D1     		bne	.L63
1108:.\Generated_Source\PSoC4/UART.c ****         {
1109:.\Generated_Source\PSoC4/UART.c ****             /* Wait for room in the FIFO */
1110:.\Generated_Source\PSoC4/UART.c ****         }
1111:.\Generated_Source\PSoC4/UART.c **** 
1112:.\Generated_Source\PSoC4/UART.c ****         /* Add directly to the FIFO */
1113:.\Generated_Source\PSoC4/UART.c ****         UART_TXDATA_REG = txDataByte;
 902              		.loc 1 1113 0 is_stmt 1
 903 001c 044B     		ldr	r3, .L64+4
 904 001e FA1D     		add	r2, r7, #7
 905 0020 1278     		ldrb	r2, [r2]
 906 0022 1A70     		strb	r2, [r3]
1114:.\Generated_Source\PSoC4/UART.c **** 
1115:.\Generated_Source\PSoC4/UART.c ****     #endif /* UART_TX_INTERRUPT_ENABLED */
1116:.\Generated_Source\PSoC4/UART.c ****     }
 907              		.loc 1 1116 0
 908 0024 BD46     		mov	sp, r7
 909 0026 02B0     		add	sp, sp, #8
 910              		@ sp needed
 911 0028 80BD     		pop	{r7, pc}
 912              	.L65:
 913 002a C046     		.align	2
 914              	.L64:
 915 002c 62000F40 		.word	1074724962
 916 0030 42000F40 		.word	1074724930
 917              		.cfi_endproc
 918              	.LFE20:
 919              		.size	UART_PutChar, .-UART_PutChar
 920              		.section	.text.UART_PutString,"ax",%progbits
 921              		.align	2
 922              		.global	UART_PutString
 923              		.code	16
 924              		.thumb_func
 925              		.type	UART_PutString, %function
 926              	UART_PutString:
 927              	.LFB21:
1117:.\Generated_Source\PSoC4/UART.c **** 
1118:.\Generated_Source\PSoC4/UART.c **** 
1119:.\Generated_Source\PSoC4/UART.c ****     /*******************************************************************************
1120:.\Generated_Source\PSoC4/UART.c ****     * Function Name: UART_PutString
1121:.\Generated_Source\PSoC4/UART.c ****     ********************************************************************************
1122:.\Generated_Source\PSoC4/UART.c ****     *
1123:.\Generated_Source\PSoC4/UART.c ****     * Summary:
1124:.\Generated_Source\PSoC4/UART.c ****     *  Sends a NULL terminated string to the TX buffer for transmission.
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 37


1125:.\Generated_Source\PSoC4/UART.c ****     *
1126:.\Generated_Source\PSoC4/UART.c ****     * Parameters:
1127:.\Generated_Source\PSoC4/UART.c ****     *  string[]: Pointer to the null terminated string array residing in RAM or ROM
1128:.\Generated_Source\PSoC4/UART.c ****     *
1129:.\Generated_Source\PSoC4/UART.c ****     * Return:
1130:.\Generated_Source\PSoC4/UART.c ****     *  None.
1131:.\Generated_Source\PSoC4/UART.c ****     *
1132:.\Generated_Source\PSoC4/UART.c ****     * Global Variables:
1133:.\Generated_Source\PSoC4/UART.c ****     *  UART_initVar - checked to identify that the component has been
1134:.\Generated_Source\PSoC4/UART.c ****     *     initialized.
1135:.\Generated_Source\PSoC4/UART.c ****     *
1136:.\Generated_Source\PSoC4/UART.c ****     * Reentrant:
1137:.\Generated_Source\PSoC4/UART.c ****     *  No.
1138:.\Generated_Source\PSoC4/UART.c ****     *
1139:.\Generated_Source\PSoC4/UART.c ****     * Theory:
1140:.\Generated_Source\PSoC4/UART.c ****     *  If there is not enough memory in the TX buffer for the entire string, this
1141:.\Generated_Source\PSoC4/UART.c ****     *  function blocks until the last character of the string is loaded into the
1142:.\Generated_Source\PSoC4/UART.c ****     *  TX buffer.
1143:.\Generated_Source\PSoC4/UART.c ****     *
1144:.\Generated_Source\PSoC4/UART.c ****     *******************************************************************************/
1145:.\Generated_Source\PSoC4/UART.c ****     void UART_PutString(const char8 string[]) 
1146:.\Generated_Source\PSoC4/UART.c ****     {
 928              		.loc 1 1146 0
 929              		.cfi_startproc
 930 0000 80B5     		push	{r7, lr}
 931              		.cfi_def_cfa_offset 8
 932              		.cfi_offset 7, -8
 933              		.cfi_offset 14, -4
 934 0002 84B0     		sub	sp, sp, #16
 935              		.cfi_def_cfa_offset 24
 936 0004 00AF     		add	r7, sp, #0
 937              		.cfi_def_cfa_register 7
 938 0006 7860     		str	r0, [r7, #4]
1147:.\Generated_Source\PSoC4/UART.c ****         uint16 bufIndex = 0u;
 939              		.loc 1 1147 0
 940 0008 3B1C     		mov	r3, r7
 941 000a 0E33     		add	r3, r3, #14
 942 000c 0022     		mov	r2, #0
 943 000e 1A80     		strh	r2, [r3]
1148:.\Generated_Source\PSoC4/UART.c **** 
1149:.\Generated_Source\PSoC4/UART.c ****         /* If not Initialized then skip this function */
1150:.\Generated_Source\PSoC4/UART.c ****         if(UART_initVar != 0u)
 944              		.loc 1 1150 0
 945 0010 0F4B     		ldr	r3, .L70
 946 0012 1B78     		ldrb	r3, [r3]
 947 0014 002B     		cmp	r3, #0
 948 0016 18D0     		beq	.L66
1151:.\Generated_Source\PSoC4/UART.c ****         {
1152:.\Generated_Source\PSoC4/UART.c ****             /* This is a blocking function, it will not exit until all data is sent */
1153:.\Generated_Source\PSoC4/UART.c ****             while(string[bufIndex] != (char8) 0)
 949              		.loc 1 1153 0
 950 0018 0FE0     		b	.L68
 951              	.L69:
1154:.\Generated_Source\PSoC4/UART.c ****             {
1155:.\Generated_Source\PSoC4/UART.c ****                 UART_PutChar((uint8)string[bufIndex]);
 952              		.loc 1 1155 0
 953 001a 3B1C     		mov	r3, r7
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 38


 954 001c 0E33     		add	r3, r3, #14
 955 001e 1B88     		ldrh	r3, [r3]
 956 0020 7A68     		ldr	r2, [r7, #4]
 957 0022 D318     		add	r3, r2, r3
 958 0024 1B78     		ldrb	r3, [r3]
 959 0026 181C     		mov	r0, r3
 960 0028 FFF7FEFF 		bl	UART_PutChar
1156:.\Generated_Source\PSoC4/UART.c ****                 bufIndex++;
 961              		.loc 1 1156 0
 962 002c 3B1C     		mov	r3, r7
 963 002e 0E33     		add	r3, r3, #14
 964 0030 1A88     		ldrh	r2, [r3]
 965 0032 3B1C     		mov	r3, r7
 966 0034 0E33     		add	r3, r3, #14
 967 0036 0132     		add	r2, r2, #1
 968 0038 1A80     		strh	r2, [r3]
 969              	.L68:
1153:.\Generated_Source\PSoC4/UART.c ****             while(string[bufIndex] != (char8) 0)
 970              		.loc 1 1153 0 discriminator 1
 971 003a 3B1C     		mov	r3, r7
 972 003c 0E33     		add	r3, r3, #14
 973 003e 1B88     		ldrh	r3, [r3]
 974 0040 7A68     		ldr	r2, [r7, #4]
 975 0042 D318     		add	r3, r2, r3
 976 0044 1B78     		ldrb	r3, [r3]
 977 0046 002B     		cmp	r3, #0
 978 0048 E7D1     		bne	.L69
 979              	.L66:
1157:.\Generated_Source\PSoC4/UART.c ****             }
1158:.\Generated_Source\PSoC4/UART.c ****         }
1159:.\Generated_Source\PSoC4/UART.c ****     }
 980              		.loc 1 1159 0
 981 004a BD46     		mov	sp, r7
 982 004c 04B0     		add	sp, sp, #16
 983              		@ sp needed
 984 004e 80BD     		pop	{r7, pc}
 985              	.L71:
 986              		.align	2
 987              	.L70:
 988 0050 00000000 		.word	UART_initVar
 989              		.cfi_endproc
 990              	.LFE21:
 991              		.size	UART_PutString, .-UART_PutString
 992              		.section	.text.UART_PutArray,"ax",%progbits
 993              		.align	2
 994              		.global	UART_PutArray
 995              		.code	16
 996              		.thumb_func
 997              		.type	UART_PutArray, %function
 998              	UART_PutArray:
 999              	.LFB22:
1160:.\Generated_Source\PSoC4/UART.c **** 
1161:.\Generated_Source\PSoC4/UART.c **** 
1162:.\Generated_Source\PSoC4/UART.c ****     /*******************************************************************************
1163:.\Generated_Source\PSoC4/UART.c ****     * Function Name: UART_PutArray
1164:.\Generated_Source\PSoC4/UART.c ****     ********************************************************************************
1165:.\Generated_Source\PSoC4/UART.c ****     *
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 39


1166:.\Generated_Source\PSoC4/UART.c ****     * Summary:
1167:.\Generated_Source\PSoC4/UART.c ****     *  Places N bytes of data from a memory array into the TX buffer for
1168:.\Generated_Source\PSoC4/UART.c ****     *  transmission.
1169:.\Generated_Source\PSoC4/UART.c ****     *
1170:.\Generated_Source\PSoC4/UART.c ****     * Parameters:
1171:.\Generated_Source\PSoC4/UART.c ****     *  string[]: Address of the memory array residing in RAM or ROM.
1172:.\Generated_Source\PSoC4/UART.c ****     *  byteCount: Number of bytes to be transmitted. The type depends on TX Buffer
1173:.\Generated_Source\PSoC4/UART.c ****     *             Size parameter.
1174:.\Generated_Source\PSoC4/UART.c ****     *
1175:.\Generated_Source\PSoC4/UART.c ****     * Return:
1176:.\Generated_Source\PSoC4/UART.c ****     *  None.
1177:.\Generated_Source\PSoC4/UART.c ****     *
1178:.\Generated_Source\PSoC4/UART.c ****     * Global Variables:
1179:.\Generated_Source\PSoC4/UART.c ****     *  UART_initVar - checked to identify that the component has been
1180:.\Generated_Source\PSoC4/UART.c ****     *     initialized.
1181:.\Generated_Source\PSoC4/UART.c ****     *
1182:.\Generated_Source\PSoC4/UART.c ****     * Reentrant:
1183:.\Generated_Source\PSoC4/UART.c ****     *  No.
1184:.\Generated_Source\PSoC4/UART.c ****     *
1185:.\Generated_Source\PSoC4/UART.c ****     * Theory:
1186:.\Generated_Source\PSoC4/UART.c ****     *  If there is not enough memory in the TX buffer for the entire string, this
1187:.\Generated_Source\PSoC4/UART.c ****     *  function blocks until the last character of the string is loaded into the
1188:.\Generated_Source\PSoC4/UART.c ****     *  TX buffer.
1189:.\Generated_Source\PSoC4/UART.c ****     *
1190:.\Generated_Source\PSoC4/UART.c ****     *******************************************************************************/
1191:.\Generated_Source\PSoC4/UART.c ****     void UART_PutArray(const uint8 string[], uint8 byteCount)
1192:.\Generated_Source\PSoC4/UART.c ****                                                                     
1193:.\Generated_Source\PSoC4/UART.c ****     {
 1000              		.loc 1 1193 0
 1001              		.cfi_startproc
 1002 0000 80B5     		push	{r7, lr}
 1003              		.cfi_def_cfa_offset 8
 1004              		.cfi_offset 7, -8
 1005              		.cfi_offset 14, -4
 1006 0002 84B0     		sub	sp, sp, #16
 1007              		.cfi_def_cfa_offset 24
 1008 0004 00AF     		add	r7, sp, #0
 1009              		.cfi_def_cfa_register 7
 1010 0006 7860     		str	r0, [r7, #4]
 1011 0008 0A1C     		mov	r2, r1
 1012 000a FB1C     		add	r3, r7, #3
 1013 000c 1A70     		strb	r2, [r3]
1194:.\Generated_Source\PSoC4/UART.c ****         uint8 bufIndex = 0u;
 1014              		.loc 1 1194 0
 1015 000e 3B1C     		mov	r3, r7
 1016 0010 0F33     		add	r3, r3, #15
 1017 0012 0022     		mov	r2, #0
 1018 0014 1A70     		strb	r2, [r3]
1195:.\Generated_Source\PSoC4/UART.c **** 
1196:.\Generated_Source\PSoC4/UART.c ****         /* If not Initialized then skip this function */
1197:.\Generated_Source\PSoC4/UART.c ****         if(UART_initVar != 0u)
 1019              		.loc 1 1197 0
 1020 0016 0F4B     		ldr	r3, .L76
 1021 0018 1B78     		ldrb	r3, [r3]
 1022 001a 002B     		cmp	r3, #0
 1023 001c 17D0     		beq	.L72
1198:.\Generated_Source\PSoC4/UART.c ****         {
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 40


1199:.\Generated_Source\PSoC4/UART.c ****             while(bufIndex < byteCount)
 1024              		.loc 1 1199 0
 1025 001e 0FE0     		b	.L74
 1026              	.L75:
1200:.\Generated_Source\PSoC4/UART.c ****             {
1201:.\Generated_Source\PSoC4/UART.c ****                 UART_PutChar(string[bufIndex]);
 1027              		.loc 1 1201 0
 1028 0020 3B1C     		mov	r3, r7
 1029 0022 0F33     		add	r3, r3, #15
 1030 0024 1B78     		ldrb	r3, [r3]
 1031 0026 7A68     		ldr	r2, [r7, #4]
 1032 0028 D318     		add	r3, r2, r3
 1033 002a 1B78     		ldrb	r3, [r3]
 1034 002c 181C     		mov	r0, r3
 1035 002e FFF7FEFF 		bl	UART_PutChar
1202:.\Generated_Source\PSoC4/UART.c ****                 bufIndex++;
 1036              		.loc 1 1202 0
 1037 0032 3B1C     		mov	r3, r7
 1038 0034 0F33     		add	r3, r3, #15
 1039 0036 1A78     		ldrb	r2, [r3]
 1040 0038 3B1C     		mov	r3, r7
 1041 003a 0F33     		add	r3, r3, #15
 1042 003c 0132     		add	r2, r2, #1
 1043 003e 1A70     		strb	r2, [r3]
 1044              	.L74:
1199:.\Generated_Source\PSoC4/UART.c ****             while(bufIndex < byteCount)
 1045              		.loc 1 1199 0 discriminator 1
 1046 0040 3A1C     		mov	r2, r7
 1047 0042 0F32     		add	r2, r2, #15
 1048 0044 FB1C     		add	r3, r7, #3
 1049 0046 1278     		ldrb	r2, [r2]
 1050 0048 1B78     		ldrb	r3, [r3]
 1051 004a 9A42     		cmp	r2, r3
 1052 004c E8D3     		bcc	.L75
 1053              	.L72:
1203:.\Generated_Source\PSoC4/UART.c ****             }
1204:.\Generated_Source\PSoC4/UART.c ****         }
1205:.\Generated_Source\PSoC4/UART.c ****     }
 1054              		.loc 1 1205 0
 1055 004e BD46     		mov	sp, r7
 1056 0050 04B0     		add	sp, sp, #16
 1057              		@ sp needed
 1058 0052 80BD     		pop	{r7, pc}
 1059              	.L77:
 1060              		.align	2
 1061              	.L76:
 1062 0054 00000000 		.word	UART_initVar
 1063              		.cfi_endproc
 1064              	.LFE22:
 1065              		.size	UART_PutArray, .-UART_PutArray
 1066              		.section	.text.UART_PutCRLF,"ax",%progbits
 1067              		.align	2
 1068              		.global	UART_PutCRLF
 1069              		.code	16
 1070              		.thumb_func
 1071              		.type	UART_PutCRLF, %function
 1072              	UART_PutCRLF:
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 41


 1073              	.LFB23:
1206:.\Generated_Source\PSoC4/UART.c **** 
1207:.\Generated_Source\PSoC4/UART.c **** 
1208:.\Generated_Source\PSoC4/UART.c ****     /*******************************************************************************
1209:.\Generated_Source\PSoC4/UART.c ****     * Function Name: UART_PutCRLF
1210:.\Generated_Source\PSoC4/UART.c ****     ********************************************************************************
1211:.\Generated_Source\PSoC4/UART.c ****     *
1212:.\Generated_Source\PSoC4/UART.c ****     * Summary:
1213:.\Generated_Source\PSoC4/UART.c ****     *  Writes a byte of data followed by a carriage return (0x0D) and line feed
1214:.\Generated_Source\PSoC4/UART.c ****     *  (0x0A) to the transmit buffer.
1215:.\Generated_Source\PSoC4/UART.c ****     *
1216:.\Generated_Source\PSoC4/UART.c ****     * Parameters:
1217:.\Generated_Source\PSoC4/UART.c ****     *  txDataByte: Data byte to transmit before the carriage return and line feed.
1218:.\Generated_Source\PSoC4/UART.c ****     *
1219:.\Generated_Source\PSoC4/UART.c ****     * Return:
1220:.\Generated_Source\PSoC4/UART.c ****     *  None.
1221:.\Generated_Source\PSoC4/UART.c ****     *
1222:.\Generated_Source\PSoC4/UART.c ****     * Global Variables:
1223:.\Generated_Source\PSoC4/UART.c ****     *  UART_initVar - checked to identify that the component has been
1224:.\Generated_Source\PSoC4/UART.c ****     *     initialized.
1225:.\Generated_Source\PSoC4/UART.c ****     *
1226:.\Generated_Source\PSoC4/UART.c ****     * Reentrant:
1227:.\Generated_Source\PSoC4/UART.c ****     *  No.
1228:.\Generated_Source\PSoC4/UART.c ****     *
1229:.\Generated_Source\PSoC4/UART.c ****     *******************************************************************************/
1230:.\Generated_Source\PSoC4/UART.c ****     void UART_PutCRLF(uint8 txDataByte) 
1231:.\Generated_Source\PSoC4/UART.c ****     {
 1074              		.loc 1 1231 0
 1075              		.cfi_startproc
 1076 0000 80B5     		push	{r7, lr}
 1077              		.cfi_def_cfa_offset 8
 1078              		.cfi_offset 7, -8
 1079              		.cfi_offset 14, -4
 1080 0002 82B0     		sub	sp, sp, #8
 1081              		.cfi_def_cfa_offset 16
 1082 0004 00AF     		add	r7, sp, #0
 1083              		.cfi_def_cfa_register 7
 1084 0006 021C     		mov	r2, r0
 1085 0008 FB1D     		add	r3, r7, #7
 1086 000a 1A70     		strb	r2, [r3]
1232:.\Generated_Source\PSoC4/UART.c ****         /* If not Initialized then skip this function */
1233:.\Generated_Source\PSoC4/UART.c ****         if(UART_initVar != 0u)
 1087              		.loc 1 1233 0
 1088 000c 084B     		ldr	r3, .L80
 1089 000e 1B78     		ldrb	r3, [r3]
 1090 0010 002B     		cmp	r3, #0
 1091 0012 0AD0     		beq	.L78
1234:.\Generated_Source\PSoC4/UART.c ****         {
1235:.\Generated_Source\PSoC4/UART.c ****             UART_PutChar(txDataByte);
 1092              		.loc 1 1235 0
 1093 0014 FB1D     		add	r3, r7, #7
 1094 0016 1B78     		ldrb	r3, [r3]
 1095 0018 181C     		mov	r0, r3
 1096 001a FFF7FEFF 		bl	UART_PutChar
1236:.\Generated_Source\PSoC4/UART.c ****             UART_PutChar(0x0Du);
 1097              		.loc 1 1236 0
 1098 001e 0D20     		mov	r0, #13
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 42


 1099 0020 FFF7FEFF 		bl	UART_PutChar
1237:.\Generated_Source\PSoC4/UART.c ****             UART_PutChar(0x0Au);
 1100              		.loc 1 1237 0
 1101 0024 0A20     		mov	r0, #10
 1102 0026 FFF7FEFF 		bl	UART_PutChar
 1103              	.L78:
1238:.\Generated_Source\PSoC4/UART.c ****         }
1239:.\Generated_Source\PSoC4/UART.c ****     }
 1104              		.loc 1 1239 0
 1105 002a BD46     		mov	sp, r7
 1106 002c 02B0     		add	sp, sp, #8
 1107              		@ sp needed
 1108 002e 80BD     		pop	{r7, pc}
 1109              	.L81:
 1110              		.align	2
 1111              	.L80:
 1112 0030 00000000 		.word	UART_initVar
 1113              		.cfi_endproc
 1114              	.LFE23:
 1115              		.size	UART_PutCRLF, .-UART_PutCRLF
 1116              		.section	.text.UART_GetTxBufferSize,"ax",%progbits
 1117              		.align	2
 1118              		.global	UART_GetTxBufferSize
 1119              		.code	16
 1120              		.thumb_func
 1121              		.type	UART_GetTxBufferSize, %function
 1122              	UART_GetTxBufferSize:
 1123              	.LFB24:
1240:.\Generated_Source\PSoC4/UART.c **** 
1241:.\Generated_Source\PSoC4/UART.c **** 
1242:.\Generated_Source\PSoC4/UART.c ****     /*******************************************************************************
1243:.\Generated_Source\PSoC4/UART.c ****     * Function Name: UART_GetTxBufferSize
1244:.\Generated_Source\PSoC4/UART.c ****     ********************************************************************************
1245:.\Generated_Source\PSoC4/UART.c ****     *
1246:.\Generated_Source\PSoC4/UART.c ****     * Summary:
1247:.\Generated_Source\PSoC4/UART.c ****     *  Returns the number of bytes in the TX buffer which are waiting to be 
1248:.\Generated_Source\PSoC4/UART.c ****     *  transmitted.
1249:.\Generated_Source\PSoC4/UART.c ****     *  * TX software buffer is disabled (TX Buffer Size parameter is equal to 4): 
1250:.\Generated_Source\PSoC4/UART.c ****     *    returns 0 for empty TX FIFO, 1 for not full TX FIFO or 4 for full TX FIFO.
1251:.\Generated_Source\PSoC4/UART.c ****     *  * TX software buffer is enabled: returns the number of bytes in the TX 
1252:.\Generated_Source\PSoC4/UART.c ****     *    software buffer which are waiting to be transmitted. Bytes available in the
1253:.\Generated_Source\PSoC4/UART.c ****     *    TX FIFO do not count.
1254:.\Generated_Source\PSoC4/UART.c ****     *
1255:.\Generated_Source\PSoC4/UART.c ****     * Parameters:
1256:.\Generated_Source\PSoC4/UART.c ****     *  None.
1257:.\Generated_Source\PSoC4/UART.c ****     *
1258:.\Generated_Source\PSoC4/UART.c ****     * Return:
1259:.\Generated_Source\PSoC4/UART.c ****     *  Number of bytes used in the TX buffer. Return value type depends on the TX 
1260:.\Generated_Source\PSoC4/UART.c ****     *  Buffer Size parameter.
1261:.\Generated_Source\PSoC4/UART.c ****     *
1262:.\Generated_Source\PSoC4/UART.c ****     * Global Variables:
1263:.\Generated_Source\PSoC4/UART.c ****     *  UART_txBufferWrite - used to calculate left space.
1264:.\Generated_Source\PSoC4/UART.c ****     *  UART_txBufferRead - used to calculate left space.
1265:.\Generated_Source\PSoC4/UART.c ****     *
1266:.\Generated_Source\PSoC4/UART.c ****     * Reentrant:
1267:.\Generated_Source\PSoC4/UART.c ****     *  No.
1268:.\Generated_Source\PSoC4/UART.c ****     *
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 43


1269:.\Generated_Source\PSoC4/UART.c ****     * Theory:
1270:.\Generated_Source\PSoC4/UART.c ****     *  Allows the user to find out how full the TX Buffer is.
1271:.\Generated_Source\PSoC4/UART.c ****     *
1272:.\Generated_Source\PSoC4/UART.c ****     *******************************************************************************/
1273:.\Generated_Source\PSoC4/UART.c ****     uint8 UART_GetTxBufferSize(void)
1274:.\Generated_Source\PSoC4/UART.c ****                                                             
1275:.\Generated_Source\PSoC4/UART.c ****     {
 1124              		.loc 1 1275 0
 1125              		.cfi_startproc
 1126 0000 80B5     		push	{r7, lr}
 1127              		.cfi_def_cfa_offset 8
 1128              		.cfi_offset 7, -8
 1129              		.cfi_offset 14, -4
 1130 0002 82B0     		sub	sp, sp, #8
 1131              		.cfi_def_cfa_offset 16
 1132 0004 00AF     		add	r7, sp, #0
 1133              		.cfi_def_cfa_register 7
1276:.\Generated_Source\PSoC4/UART.c ****         uint8 size;
1277:.\Generated_Source\PSoC4/UART.c **** 
1278:.\Generated_Source\PSoC4/UART.c ****     #if (UART_TX_INTERRUPT_ENABLED)
1279:.\Generated_Source\PSoC4/UART.c **** 
1280:.\Generated_Source\PSoC4/UART.c ****         /* Protect variables that could change on interrupt. */
1281:.\Generated_Source\PSoC4/UART.c ****         UART_DisableTxInt();
1282:.\Generated_Source\PSoC4/UART.c **** 
1283:.\Generated_Source\PSoC4/UART.c ****         if(UART_txBufferRead == UART_txBufferWrite)
1284:.\Generated_Source\PSoC4/UART.c ****         {
1285:.\Generated_Source\PSoC4/UART.c ****             size = 0u;
1286:.\Generated_Source\PSoC4/UART.c ****         }
1287:.\Generated_Source\PSoC4/UART.c ****         else if(UART_txBufferRead < UART_txBufferWrite)
1288:.\Generated_Source\PSoC4/UART.c ****         {
1289:.\Generated_Source\PSoC4/UART.c ****             size = (UART_txBufferWrite - UART_txBufferRead);
1290:.\Generated_Source\PSoC4/UART.c ****         }
1291:.\Generated_Source\PSoC4/UART.c ****         else
1292:.\Generated_Source\PSoC4/UART.c ****         {
1293:.\Generated_Source\PSoC4/UART.c ****             size = (UART_TX_BUFFER_SIZE - UART_txBufferRead) +
1294:.\Generated_Source\PSoC4/UART.c ****                     UART_txBufferWrite;
1295:.\Generated_Source\PSoC4/UART.c ****         }
1296:.\Generated_Source\PSoC4/UART.c **** 
1297:.\Generated_Source\PSoC4/UART.c ****         UART_EnableTxInt();
1298:.\Generated_Source\PSoC4/UART.c **** 
1299:.\Generated_Source\PSoC4/UART.c ****     #else
1300:.\Generated_Source\PSoC4/UART.c **** 
1301:.\Generated_Source\PSoC4/UART.c ****         size = UART_TXSTATUS_REG;
 1134              		.loc 1 1301 0
 1135 0006 0F4A     		ldr	r2, .L87
 1136 0008 FB1D     		add	r3, r7, #7
 1137 000a 1278     		ldrb	r2, [r2]
 1138 000c 1A70     		strb	r2, [r3]
1302:.\Generated_Source\PSoC4/UART.c **** 
1303:.\Generated_Source\PSoC4/UART.c ****         /* Is the fifo is full. */
1304:.\Generated_Source\PSoC4/UART.c ****         if((size & UART_TX_STS_FIFO_FULL) != 0u)
 1139              		.loc 1 1304 0
 1140 000e FB1D     		add	r3, r7, #7
 1141 0010 1A78     		ldrb	r2, [r3]
 1142 0012 0423     		mov	r3, #4
 1143 0014 1340     		and	r3, r2
 1144 0016 03D0     		beq	.L83
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 44


1305:.\Generated_Source\PSoC4/UART.c ****         {
1306:.\Generated_Source\PSoC4/UART.c ****             size = UART_FIFO_LENGTH;
 1145              		.loc 1 1306 0
 1146 0018 FB1D     		add	r3, r7, #7
 1147 001a 0422     		mov	r2, #4
 1148 001c 1A70     		strb	r2, [r3]
 1149 001e 0BE0     		b	.L84
 1150              	.L83:
1307:.\Generated_Source\PSoC4/UART.c ****         }
1308:.\Generated_Source\PSoC4/UART.c ****         else if((size & UART_TX_STS_FIFO_EMPTY) != 0u)
 1151              		.loc 1 1308 0
 1152 0020 FB1D     		add	r3, r7, #7
 1153 0022 1A78     		ldrb	r2, [r3]
 1154 0024 0223     		mov	r3, #2
 1155 0026 1340     		and	r3, r2
 1156 0028 03D0     		beq	.L85
1309:.\Generated_Source\PSoC4/UART.c ****         {
1310:.\Generated_Source\PSoC4/UART.c ****             size = 0u;
 1157              		.loc 1 1310 0
 1158 002a FB1D     		add	r3, r7, #7
 1159 002c 0022     		mov	r2, #0
 1160 002e 1A70     		strb	r2, [r3]
 1161 0030 02E0     		b	.L84
 1162              	.L85:
1311:.\Generated_Source\PSoC4/UART.c ****         }
1312:.\Generated_Source\PSoC4/UART.c ****         else
1313:.\Generated_Source\PSoC4/UART.c ****         {
1314:.\Generated_Source\PSoC4/UART.c ****             /* We only know there is data in the fifo. */
1315:.\Generated_Source\PSoC4/UART.c ****             size = 1u;
 1163              		.loc 1 1315 0
 1164 0032 FB1D     		add	r3, r7, #7
 1165 0034 0122     		mov	r2, #1
 1166 0036 1A70     		strb	r2, [r3]
 1167              	.L84:
1316:.\Generated_Source\PSoC4/UART.c ****         }
1317:.\Generated_Source\PSoC4/UART.c **** 
1318:.\Generated_Source\PSoC4/UART.c ****     #endif /* (UART_TX_INTERRUPT_ENABLED) */
1319:.\Generated_Source\PSoC4/UART.c **** 
1320:.\Generated_Source\PSoC4/UART.c ****     return(size);
 1168              		.loc 1 1320 0
 1169 0038 FB1D     		add	r3, r7, #7
 1170 003a 1B78     		ldrb	r3, [r3]
1321:.\Generated_Source\PSoC4/UART.c ****     }
 1171              		.loc 1 1321 0
 1172 003c 181C     		mov	r0, r3
 1173 003e BD46     		mov	sp, r7
 1174 0040 02B0     		add	sp, sp, #8
 1175              		@ sp needed
 1176 0042 80BD     		pop	{r7, pc}
 1177              	.L88:
 1178              		.align	2
 1179              	.L87:
 1180 0044 62000F40 		.word	1074724962
 1181              		.cfi_endproc
 1182              	.LFE24:
 1183              		.size	UART_GetTxBufferSize, .-UART_GetTxBufferSize
 1184              		.section	.text.UART_ClearTxBuffer,"ax",%progbits
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 45


 1185              		.align	2
 1186              		.global	UART_ClearTxBuffer
 1187              		.code	16
 1188              		.thumb_func
 1189              		.type	UART_ClearTxBuffer, %function
 1190              	UART_ClearTxBuffer:
 1191              	.LFB25:
1322:.\Generated_Source\PSoC4/UART.c **** 
1323:.\Generated_Source\PSoC4/UART.c **** 
1324:.\Generated_Source\PSoC4/UART.c ****     /*******************************************************************************
1325:.\Generated_Source\PSoC4/UART.c ****     * Function Name: UART_ClearTxBuffer
1326:.\Generated_Source\PSoC4/UART.c ****     ********************************************************************************
1327:.\Generated_Source\PSoC4/UART.c ****     *
1328:.\Generated_Source\PSoC4/UART.c ****     * Summary:
1329:.\Generated_Source\PSoC4/UART.c ****     *  Clears all data from the TX buffer and hardware TX FIFO.
1330:.\Generated_Source\PSoC4/UART.c ****     *
1331:.\Generated_Source\PSoC4/UART.c ****     * Parameters:
1332:.\Generated_Source\PSoC4/UART.c ****     *  None.
1333:.\Generated_Source\PSoC4/UART.c ****     *
1334:.\Generated_Source\PSoC4/UART.c ****     * Return:
1335:.\Generated_Source\PSoC4/UART.c ****     *  None.
1336:.\Generated_Source\PSoC4/UART.c ****     *
1337:.\Generated_Source\PSoC4/UART.c ****     * Global Variables:
1338:.\Generated_Source\PSoC4/UART.c ****     *  UART_txBufferWrite - cleared to zero.
1339:.\Generated_Source\PSoC4/UART.c ****     *  UART_txBufferRead - cleared to zero.
1340:.\Generated_Source\PSoC4/UART.c ****     *
1341:.\Generated_Source\PSoC4/UART.c ****     * Reentrant:
1342:.\Generated_Source\PSoC4/UART.c ****     *  No.
1343:.\Generated_Source\PSoC4/UART.c ****     *
1344:.\Generated_Source\PSoC4/UART.c ****     * Theory:
1345:.\Generated_Source\PSoC4/UART.c ****     *  Setting the pointers to zero makes the system believe there is no data to
1346:.\Generated_Source\PSoC4/UART.c ****     *  read and writing will resume at address 0 overwriting any data that may have
1347:.\Generated_Source\PSoC4/UART.c ****     *  remained in the RAM.
1348:.\Generated_Source\PSoC4/UART.c ****     *
1349:.\Generated_Source\PSoC4/UART.c ****     * Side Effects:
1350:.\Generated_Source\PSoC4/UART.c ****     *  Data waiting in the transmit buffer is not sent; a byte that is currently
1351:.\Generated_Source\PSoC4/UART.c ****     *  transmitting finishes transmitting.
1352:.\Generated_Source\PSoC4/UART.c ****     *
1353:.\Generated_Source\PSoC4/UART.c ****     *******************************************************************************/
1354:.\Generated_Source\PSoC4/UART.c ****     void UART_ClearTxBuffer(void) 
1355:.\Generated_Source\PSoC4/UART.c ****     {
 1192              		.loc 1 1355 0
 1193              		.cfi_startproc
 1194 0000 90B5     		push	{r4, r7, lr}
 1195              		.cfi_def_cfa_offset 12
 1196              		.cfi_offset 4, -12
 1197              		.cfi_offset 7, -8
 1198              		.cfi_offset 14, -4
 1199 0002 83B0     		sub	sp, sp, #12
 1200              		.cfi_def_cfa_offset 24
 1201 0004 00AF     		add	r7, sp, #0
 1202              		.cfi_def_cfa_register 7
1356:.\Generated_Source\PSoC4/UART.c ****         uint8 enableInterrupts;
1357:.\Generated_Source\PSoC4/UART.c **** 
1358:.\Generated_Source\PSoC4/UART.c ****         enableInterrupts = CyEnterCriticalSection();
 1203              		.loc 1 1358 0
 1204 0006 FC1D     		add	r4, r7, #7
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 46


 1205 0008 FFF7FEFF 		bl	CyEnterCriticalSection
 1206 000c 031C     		mov	r3, r0
 1207 000e 2370     		strb	r3, [r4]
1359:.\Generated_Source\PSoC4/UART.c ****         /* Clear the HW FIFO */
1360:.\Generated_Source\PSoC4/UART.c ****         UART_TXDATA_AUX_CTL_REG |= (uint8)  UART_TX_FIFO_CLR;
 1208              		.loc 1 1360 0
 1209 0010 0B4B     		ldr	r3, .L90
 1210 0012 0B4A     		ldr	r2, .L90
 1211 0014 1278     		ldrb	r2, [r2]
 1212 0016 D2B2     		uxtb	r2, r2
 1213 0018 0121     		mov	r1, #1
 1214 001a 0A43     		orr	r2, r1
 1215 001c D2B2     		uxtb	r2, r2
 1216 001e 1A70     		strb	r2, [r3]
1361:.\Generated_Source\PSoC4/UART.c ****         UART_TXDATA_AUX_CTL_REG &= (uint8) ~UART_TX_FIFO_CLR;
 1217              		.loc 1 1361 0
 1218 0020 074B     		ldr	r3, .L90
 1219 0022 074A     		ldr	r2, .L90
 1220 0024 1278     		ldrb	r2, [r2]
 1221 0026 D2B2     		uxtb	r2, r2
 1222 0028 0121     		mov	r1, #1
 1223 002a 8A43     		bic	r2, r1
 1224 002c D2B2     		uxtb	r2, r2
 1225 002e 1A70     		strb	r2, [r3]
1362:.\Generated_Source\PSoC4/UART.c ****         CyExitCriticalSection(enableInterrupts);
 1226              		.loc 1 1362 0
 1227 0030 FB1D     		add	r3, r7, #7
 1228 0032 1B78     		ldrb	r3, [r3]
 1229 0034 181C     		mov	r0, r3
 1230 0036 FFF7FEFF 		bl	CyExitCriticalSection
1363:.\Generated_Source\PSoC4/UART.c **** 
1364:.\Generated_Source\PSoC4/UART.c ****     #if (UART_TX_INTERRUPT_ENABLED)
1365:.\Generated_Source\PSoC4/UART.c **** 
1366:.\Generated_Source\PSoC4/UART.c ****         /* Protect variables that could change on interrupt. */
1367:.\Generated_Source\PSoC4/UART.c ****         UART_DisableTxInt();
1368:.\Generated_Source\PSoC4/UART.c **** 
1369:.\Generated_Source\PSoC4/UART.c ****         UART_txBufferRead = 0u;
1370:.\Generated_Source\PSoC4/UART.c ****         UART_txBufferWrite = 0u;
1371:.\Generated_Source\PSoC4/UART.c **** 
1372:.\Generated_Source\PSoC4/UART.c ****         /* Enable Tx interrupt. */
1373:.\Generated_Source\PSoC4/UART.c ****         UART_EnableTxInt();
1374:.\Generated_Source\PSoC4/UART.c **** 
1375:.\Generated_Source\PSoC4/UART.c ****     #endif /* (UART_TX_INTERRUPT_ENABLED) */
1376:.\Generated_Source\PSoC4/UART.c ****     }
 1231              		.loc 1 1376 0
 1232 003a BD46     		mov	sp, r7
 1233 003c 03B0     		add	sp, sp, #12
 1234              		@ sp needed
 1235 003e 90BD     		pop	{r4, r7, pc}
 1236              	.L91:
 1237              		.align	2
 1238              	.L90:
 1239 0040 92000F40 		.word	1074725010
 1240              		.cfi_endproc
 1241              	.LFE25:
 1242              		.size	UART_ClearTxBuffer, .-UART_ClearTxBuffer
 1243              		.section	.text.UART_SendBreak,"ax",%progbits
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 47


 1244              		.align	2
 1245              		.global	UART_SendBreak
 1246              		.code	16
 1247              		.thumb_func
 1248              		.type	UART_SendBreak, %function
 1249              	UART_SendBreak:
 1250              	.LFB26:
1377:.\Generated_Source\PSoC4/UART.c **** 
1378:.\Generated_Source\PSoC4/UART.c **** 
1379:.\Generated_Source\PSoC4/UART.c ****     /*******************************************************************************
1380:.\Generated_Source\PSoC4/UART.c ****     * Function Name: UART_SendBreak
1381:.\Generated_Source\PSoC4/UART.c ****     ********************************************************************************
1382:.\Generated_Source\PSoC4/UART.c ****     *
1383:.\Generated_Source\PSoC4/UART.c ****     * Summary:
1384:.\Generated_Source\PSoC4/UART.c ****     *  Transmits a break signal on the bus.
1385:.\Generated_Source\PSoC4/UART.c ****     *
1386:.\Generated_Source\PSoC4/UART.c ****     * Parameters:
1387:.\Generated_Source\PSoC4/UART.c ****     *  uint8 retMode:  Send Break return mode. See the following table for options.
1388:.\Generated_Source\PSoC4/UART.c ****     *   UART_SEND_BREAK - Initialize registers for break, send the Break
1389:.\Generated_Source\PSoC4/UART.c ****     *       signal and return immediately.
1390:.\Generated_Source\PSoC4/UART.c ****     *   UART_WAIT_FOR_COMPLETE_REINIT - Wait until break transmission is
1391:.\Generated_Source\PSoC4/UART.c ****     *       complete, reinitialize registers to normal transmission mode then return
1392:.\Generated_Source\PSoC4/UART.c ****     *   UART_REINIT - Reinitialize registers to normal transmission mode
1393:.\Generated_Source\PSoC4/UART.c ****     *       then return.
1394:.\Generated_Source\PSoC4/UART.c ****     *   UART_SEND_WAIT_REINIT - Performs both options: 
1395:.\Generated_Source\PSoC4/UART.c ****     *      UART_SEND_BREAK and UART_WAIT_FOR_COMPLETE_REINIT.
1396:.\Generated_Source\PSoC4/UART.c ****     *      This option is recommended for most cases.
1397:.\Generated_Source\PSoC4/UART.c ****     *
1398:.\Generated_Source\PSoC4/UART.c ****     * Return:
1399:.\Generated_Source\PSoC4/UART.c ****     *  None.
1400:.\Generated_Source\PSoC4/UART.c ****     *
1401:.\Generated_Source\PSoC4/UART.c ****     * Global Variables:
1402:.\Generated_Source\PSoC4/UART.c ****     *  UART_initVar - checked to identify that the component has been
1403:.\Generated_Source\PSoC4/UART.c ****     *     initialized.
1404:.\Generated_Source\PSoC4/UART.c ****     *  txPeriod - static variable, used for keeping TX period configuration.
1405:.\Generated_Source\PSoC4/UART.c ****     *
1406:.\Generated_Source\PSoC4/UART.c ****     * Reentrant:
1407:.\Generated_Source\PSoC4/UART.c ****     *  No.
1408:.\Generated_Source\PSoC4/UART.c ****     *
1409:.\Generated_Source\PSoC4/UART.c ****     * Theory:
1410:.\Generated_Source\PSoC4/UART.c ****     *  SendBreak function initializes registers to send 13-bit break signal. It is
1411:.\Generated_Source\PSoC4/UART.c ****     *  important to return the registers configuration to normal for continue 8-bit
1412:.\Generated_Source\PSoC4/UART.c ****     *  operation.
1413:.\Generated_Source\PSoC4/UART.c ****     *  There are 3 variants for this API usage:
1414:.\Generated_Source\PSoC4/UART.c ****     *  1) SendBreak(3) - function will send the Break signal and take care on the
1415:.\Generated_Source\PSoC4/UART.c ****     *     configuration returning. Function will block CPU until transmission
1416:.\Generated_Source\PSoC4/UART.c ****     *     complete.
1417:.\Generated_Source\PSoC4/UART.c ****     *  2) User may want to use blocking time if UART configured to the low speed
1418:.\Generated_Source\PSoC4/UART.c ****     *     operation
1419:.\Generated_Source\PSoC4/UART.c ****     *     Example for this case:
1420:.\Generated_Source\PSoC4/UART.c ****     *     SendBreak(0);     - initialize Break signal transmission
1421:.\Generated_Source\PSoC4/UART.c ****     *         Add your code here to use CPU time
1422:.\Generated_Source\PSoC4/UART.c ****     *     SendBreak(1);     - complete Break operation
1423:.\Generated_Source\PSoC4/UART.c ****     *  3) Same to 2) but user may want to initialize and use the interrupt to
1424:.\Generated_Source\PSoC4/UART.c ****     *     complete break operation.
1425:.\Generated_Source\PSoC4/UART.c ****     *     Example for this case:
1426:.\Generated_Source\PSoC4/UART.c ****     *     Initialize TX interrupt with "TX - On TX Complete" parameter
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 48


1427:.\Generated_Source\PSoC4/UART.c ****     *     SendBreak(0);     - initialize Break signal transmission
1428:.\Generated_Source\PSoC4/UART.c ****     *         Add your code here to use CPU time
1429:.\Generated_Source\PSoC4/UART.c ****     *     When interrupt appear with UART_TX_STS_COMPLETE status:
1430:.\Generated_Source\PSoC4/UART.c ****     *     SendBreak(2);     - complete Break operation
1431:.\Generated_Source\PSoC4/UART.c ****     *
1432:.\Generated_Source\PSoC4/UART.c ****     * Side Effects:
1433:.\Generated_Source\PSoC4/UART.c ****     *  The UART_SendBreak() function initializes registers to send a
1434:.\Generated_Source\PSoC4/UART.c ****     *  break signal.
1435:.\Generated_Source\PSoC4/UART.c ****     *  Break signal length depends on the break signal bits configuration.
1436:.\Generated_Source\PSoC4/UART.c ****     *  The register configuration should be reinitialized before normal 8-bit
1437:.\Generated_Source\PSoC4/UART.c ****     *  communication can continue.
1438:.\Generated_Source\PSoC4/UART.c ****     *
1439:.\Generated_Source\PSoC4/UART.c ****     *******************************************************************************/
1440:.\Generated_Source\PSoC4/UART.c ****     void UART_SendBreak(uint8 retMode) 
1441:.\Generated_Source\PSoC4/UART.c ****     {
 1251              		.loc 1 1441 0
 1252              		.cfi_startproc
 1253 0000 80B5     		push	{r7, lr}
 1254              		.cfi_def_cfa_offset 8
 1255              		.cfi_offset 7, -8
 1256              		.cfi_offset 14, -4
 1257 0002 84B0     		sub	sp, sp, #16
 1258              		.cfi_def_cfa_offset 24
 1259 0004 00AF     		add	r7, sp, #0
 1260              		.cfi_def_cfa_register 7
 1261 0006 021C     		mov	r2, r0
 1262 0008 FB1D     		add	r3, r7, #7
 1263 000a 1A70     		strb	r2, [r3]
1442:.\Generated_Source\PSoC4/UART.c **** 
1443:.\Generated_Source\PSoC4/UART.c ****         /* If not Initialized then skip this function*/
1444:.\Generated_Source\PSoC4/UART.c ****         if(UART_initVar != 0u)
 1264              		.loc 1 1444 0
 1265 000c 254B     		ldr	r3, .L100
 1266 000e 1B78     		ldrb	r3, [r3]
 1267 0010 002B     		cmp	r3, #0
 1268 0012 43D0     		beq	.L92
 1269              	.LBB2:
1445:.\Generated_Source\PSoC4/UART.c ****         {
1446:.\Generated_Source\PSoC4/UART.c ****             /* Set the Counter to 13-bits and transmit a 00 byte */
1447:.\Generated_Source\PSoC4/UART.c ****             /* When that is done then reset the counter value back */
1448:.\Generated_Source\PSoC4/UART.c ****             uint8 tmpStat;
1449:.\Generated_Source\PSoC4/UART.c **** 
1450:.\Generated_Source\PSoC4/UART.c ****         #if(UART_HD_ENABLED) /* Half Duplex mode*/
1451:.\Generated_Source\PSoC4/UART.c **** 
1452:.\Generated_Source\PSoC4/UART.c ****             if( (retMode == UART_SEND_BREAK) ||
1453:.\Generated_Source\PSoC4/UART.c ****                 (retMode == UART_SEND_WAIT_REINIT ) )
1454:.\Generated_Source\PSoC4/UART.c ****             {
1455:.\Generated_Source\PSoC4/UART.c ****                 /* CTRL_HD_SEND_BREAK - sends break bits in HD mode */
1456:.\Generated_Source\PSoC4/UART.c ****                 UART_WriteControlRegister(UART_ReadControlRegister() |
1457:.\Generated_Source\PSoC4/UART.c ****                                                       UART_CTRL_HD_SEND_BREAK);
1458:.\Generated_Source\PSoC4/UART.c ****                 /* Send zeros */
1459:.\Generated_Source\PSoC4/UART.c ****                 UART_TXDATA_REG = 0u;
1460:.\Generated_Source\PSoC4/UART.c **** 
1461:.\Generated_Source\PSoC4/UART.c ****                 do /* Wait until transmit starts */
1462:.\Generated_Source\PSoC4/UART.c ****                 {
1463:.\Generated_Source\PSoC4/UART.c ****                     tmpStat = UART_TXSTATUS_REG;
1464:.\Generated_Source\PSoC4/UART.c ****                 }
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 49


1465:.\Generated_Source\PSoC4/UART.c ****                 while((tmpStat & UART_TX_STS_FIFO_EMPTY) != 0u);
1466:.\Generated_Source\PSoC4/UART.c ****             }
1467:.\Generated_Source\PSoC4/UART.c **** 
1468:.\Generated_Source\PSoC4/UART.c ****             if( (retMode == UART_WAIT_FOR_COMPLETE_REINIT) ||
1469:.\Generated_Source\PSoC4/UART.c ****                 (retMode == UART_SEND_WAIT_REINIT) )
1470:.\Generated_Source\PSoC4/UART.c ****             {
1471:.\Generated_Source\PSoC4/UART.c ****                 do /* Wait until transmit complete */
1472:.\Generated_Source\PSoC4/UART.c ****                 {
1473:.\Generated_Source\PSoC4/UART.c ****                     tmpStat = UART_TXSTATUS_REG;
1474:.\Generated_Source\PSoC4/UART.c ****                 }
1475:.\Generated_Source\PSoC4/UART.c ****                 while(((uint8)~tmpStat & UART_TX_STS_COMPLETE) != 0u);
1476:.\Generated_Source\PSoC4/UART.c ****             }
1477:.\Generated_Source\PSoC4/UART.c **** 
1478:.\Generated_Source\PSoC4/UART.c ****             if( (retMode == UART_WAIT_FOR_COMPLETE_REINIT) ||
1479:.\Generated_Source\PSoC4/UART.c ****                 (retMode == UART_REINIT) ||
1480:.\Generated_Source\PSoC4/UART.c ****                 (retMode == UART_SEND_WAIT_REINIT) )
1481:.\Generated_Source\PSoC4/UART.c ****             {
1482:.\Generated_Source\PSoC4/UART.c ****                 UART_WriteControlRegister(UART_ReadControlRegister() &
1483:.\Generated_Source\PSoC4/UART.c ****                                               (uint8)~UART_CTRL_HD_SEND_BREAK);
1484:.\Generated_Source\PSoC4/UART.c ****             }
1485:.\Generated_Source\PSoC4/UART.c **** 
1486:.\Generated_Source\PSoC4/UART.c ****         #else /* UART_HD_ENABLED Full Duplex mode */
1487:.\Generated_Source\PSoC4/UART.c **** 
1488:.\Generated_Source\PSoC4/UART.c ****             static uint8 txPeriod;
1489:.\Generated_Source\PSoC4/UART.c **** 
1490:.\Generated_Source\PSoC4/UART.c ****             if( (retMode == UART_SEND_BREAK) ||
 1270              		.loc 1 1490 0
 1271 0014 FB1D     		add	r3, r7, #7
 1272 0016 1B78     		ldrb	r3, [r3]
 1273 0018 002B     		cmp	r3, #0
 1274 001a 03D0     		beq	.L94
 1275              		.loc 1 1490 0 is_stmt 0 discriminator 1
 1276 001c FB1D     		add	r3, r7, #7
 1277 001e 1B78     		ldrb	r3, [r3]
 1278 0020 032B     		cmp	r3, #3
 1279 0022 15D1     		bne	.L95
 1280              	.L94:
1491:.\Generated_Source\PSoC4/UART.c ****                 (retMode == UART_SEND_WAIT_REINIT) )
1492:.\Generated_Source\PSoC4/UART.c ****             {
1493:.\Generated_Source\PSoC4/UART.c ****                 /* CTRL_HD_SEND_BREAK - skip to send parity bit at Break signal in Full Duplex mode
1494:.\Generated_Source\PSoC4/UART.c ****                 #if( (UART_PARITY_TYPE != UART__B_UART__NONE_REVB) || \
1495:.\Generated_Source\PSoC4/UART.c ****                                     (UART_PARITY_TYPE_SW != 0u) )
1496:.\Generated_Source\PSoC4/UART.c ****                     UART_WriteControlRegister(UART_ReadControlRegister() |
1497:.\Generated_Source\PSoC4/UART.c ****                                                           UART_CTRL_HD_SEND_BREAK);
1498:.\Generated_Source\PSoC4/UART.c ****                 #endif /* End UART_PARITY_TYPE != UART__B_UART__NONE_REVB  */
1499:.\Generated_Source\PSoC4/UART.c **** 
1500:.\Generated_Source\PSoC4/UART.c ****                 #if(UART_TXCLKGEN_DP)
1501:.\Generated_Source\PSoC4/UART.c ****                     txPeriod = UART_TXBITCLKTX_COMPLETE_REG;
 1281              		.loc 1 1501 0 is_stmt 1
 1282 0024 204B     		ldr	r3, .L100+4
 1283 0026 1B78     		ldrb	r3, [r3]
 1284 0028 DAB2     		uxtb	r2, r3
 1285 002a 204B     		ldr	r3, .L100+8
 1286 002c 1A70     		strb	r2, [r3]
1502:.\Generated_Source\PSoC4/UART.c ****                     UART_TXBITCLKTX_COMPLETE_REG = UART_TXBITCTR_BREAKBITS;
 1287              		.loc 1 1502 0
 1288 002e 1E4B     		ldr	r3, .L100+4
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 50


 1289 0030 6722     		mov	r2, #103
 1290 0032 1A70     		strb	r2, [r3]
1503:.\Generated_Source\PSoC4/UART.c ****                 #else
1504:.\Generated_Source\PSoC4/UART.c ****                     txPeriod = UART_TXBITCTR_PERIOD_REG;
1505:.\Generated_Source\PSoC4/UART.c ****                     UART_TXBITCTR_PERIOD_REG = UART_TXBITCTR_BREAKBITS8X;
1506:.\Generated_Source\PSoC4/UART.c ****                 #endif /* End UART_TXCLKGEN_DP */
1507:.\Generated_Source\PSoC4/UART.c **** 
1508:.\Generated_Source\PSoC4/UART.c ****                 /* Send zeros */
1509:.\Generated_Source\PSoC4/UART.c ****                 UART_TXDATA_REG = 0u;
 1291              		.loc 1 1509 0
 1292 0034 1E4B     		ldr	r3, .L100+12
 1293 0036 0022     		mov	r2, #0
 1294 0038 1A70     		strb	r2, [r3]
 1295              	.L96:
1510:.\Generated_Source\PSoC4/UART.c **** 
1511:.\Generated_Source\PSoC4/UART.c ****                 do /* Wait until transmit starts */
1512:.\Generated_Source\PSoC4/UART.c ****                 {
1513:.\Generated_Source\PSoC4/UART.c ****                     tmpStat = UART_TXSTATUS_REG;
 1296              		.loc 1 1513 0 discriminator 1
 1297 003a 1E4A     		ldr	r2, .L100+16
 1298 003c 3B1C     		mov	r3, r7
 1299 003e 0F33     		add	r3, r3, #15
 1300 0040 1278     		ldrb	r2, [r2]
 1301 0042 1A70     		strb	r2, [r3]
1514:.\Generated_Source\PSoC4/UART.c ****                 }
1515:.\Generated_Source\PSoC4/UART.c ****                 while((tmpStat & UART_TX_STS_FIFO_EMPTY) != 0u);
 1302              		.loc 1 1515 0 discriminator 1
 1303 0044 3B1C     		mov	r3, r7
 1304 0046 0F33     		add	r3, r3, #15
 1305 0048 1A78     		ldrb	r2, [r3]
 1306 004a 0223     		mov	r3, #2
 1307 004c 1340     		and	r3, r2
 1308 004e F4D1     		bne	.L96
 1309              	.L95:
1516:.\Generated_Source\PSoC4/UART.c ****             }
1517:.\Generated_Source\PSoC4/UART.c **** 
1518:.\Generated_Source\PSoC4/UART.c ****             if( (retMode == UART_WAIT_FOR_COMPLETE_REINIT) ||
 1310              		.loc 1 1518 0
 1311 0050 FB1D     		add	r3, r7, #7
 1312 0052 1B78     		ldrb	r3, [r3]
 1313 0054 012B     		cmp	r3, #1
 1314 0056 03D0     		beq	.L97
 1315              		.loc 1 1518 0 is_stmt 0 discriminator 1
 1316 0058 FB1D     		add	r3, r7, #7
 1317 005a 1B78     		ldrb	r3, [r3]
 1318 005c 032B     		cmp	r3, #3
 1319 005e 0DD1     		bne	.L98
 1320              	.L97:
1519:.\Generated_Source\PSoC4/UART.c ****                 (retMode == UART_SEND_WAIT_REINIT) )
1520:.\Generated_Source\PSoC4/UART.c ****             {
1521:.\Generated_Source\PSoC4/UART.c ****                 do /* Wait until transmit complete */
1522:.\Generated_Source\PSoC4/UART.c ****                 {
1523:.\Generated_Source\PSoC4/UART.c ****                     tmpStat = UART_TXSTATUS_REG;
 1321              		.loc 1 1523 0 is_stmt 1 discriminator 1
 1322 0060 144A     		ldr	r2, .L100+16
 1323 0062 3B1C     		mov	r3, r7
 1324 0064 0F33     		add	r3, r3, #15
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 51


 1325 0066 1278     		ldrb	r2, [r2]
 1326 0068 1A70     		strb	r2, [r3]
1524:.\Generated_Source\PSoC4/UART.c ****                 }
1525:.\Generated_Source\PSoC4/UART.c ****                 while(((uint8)~tmpStat & UART_TX_STS_COMPLETE) != 0u);
 1327              		.loc 1 1525 0 discriminator 1
 1328 006a 3B1C     		mov	r3, r7
 1329 006c 0F33     		add	r3, r3, #15
 1330 006e 1B78     		ldrb	r3, [r3]
 1331 0070 DB43     		mvn	r3, r3
 1332 0072 DBB2     		uxtb	r3, r3
 1333 0074 1A1C     		mov	r2, r3
 1334 0076 0123     		mov	r3, #1
 1335 0078 1340     		and	r3, r2
 1336 007a F1D1     		bne	.L97
 1337              	.L98:
1526:.\Generated_Source\PSoC4/UART.c ****             }
1527:.\Generated_Source\PSoC4/UART.c **** 
1528:.\Generated_Source\PSoC4/UART.c ****             if( (retMode == UART_WAIT_FOR_COMPLETE_REINIT) ||
 1338              		.loc 1 1528 0
 1339 007c FB1D     		add	r3, r7, #7
 1340 007e 1B78     		ldrb	r3, [r3]
 1341 0080 012B     		cmp	r3, #1
 1342 0082 07D0     		beq	.L99
 1343              		.loc 1 1528 0 is_stmt 0 discriminator 1
 1344 0084 FB1D     		add	r3, r7, #7
 1345 0086 1B78     		ldrb	r3, [r3]
 1346 0088 022B     		cmp	r3, #2
 1347 008a 03D0     		beq	.L99
1529:.\Generated_Source\PSoC4/UART.c ****                 (retMode == UART_REINIT) ||
 1348              		.loc 1 1529 0 is_stmt 1
 1349 008c FB1D     		add	r3, r7, #7
 1350 008e 1B78     		ldrb	r3, [r3]
 1351 0090 032B     		cmp	r3, #3
 1352 0092 03D1     		bne	.L92
 1353              	.L99:
1530:.\Generated_Source\PSoC4/UART.c ****                 (retMode == UART_SEND_WAIT_REINIT) )
1531:.\Generated_Source\PSoC4/UART.c ****             {
1532:.\Generated_Source\PSoC4/UART.c **** 
1533:.\Generated_Source\PSoC4/UART.c ****             #if(UART_TXCLKGEN_DP)
1534:.\Generated_Source\PSoC4/UART.c ****                 UART_TXBITCLKTX_COMPLETE_REG = txPeriod;
 1354              		.loc 1 1534 0
 1355 0094 044B     		ldr	r3, .L100+4
 1356 0096 054A     		ldr	r2, .L100+8
 1357 0098 1278     		ldrb	r2, [r2]
 1358 009a 1A70     		strb	r2, [r3]
 1359              	.L92:
 1360              	.LBE2:
1535:.\Generated_Source\PSoC4/UART.c ****             #else
1536:.\Generated_Source\PSoC4/UART.c ****                 UART_TXBITCTR_PERIOD_REG = txPeriod;
1537:.\Generated_Source\PSoC4/UART.c ****             #endif /* End UART_TXCLKGEN_DP */
1538:.\Generated_Source\PSoC4/UART.c **** 
1539:.\Generated_Source\PSoC4/UART.c ****             #if( (UART_PARITY_TYPE != UART__B_UART__NONE_REVB) || \
1540:.\Generated_Source\PSoC4/UART.c ****                  (UART_PARITY_TYPE_SW != 0u) )
1541:.\Generated_Source\PSoC4/UART.c ****                 UART_WriteControlRegister(UART_ReadControlRegister() &
1542:.\Generated_Source\PSoC4/UART.c ****                                                       (uint8) ~UART_CTRL_HD_SEND_BREAK);
1543:.\Generated_Source\PSoC4/UART.c ****             #endif /* End UART_PARITY_TYPE != NONE */
1544:.\Generated_Source\PSoC4/UART.c ****             }
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 52


1545:.\Generated_Source\PSoC4/UART.c ****         #endif    /* End UART_HD_ENABLED */
1546:.\Generated_Source\PSoC4/UART.c ****         }
1547:.\Generated_Source\PSoC4/UART.c ****     }
 1361              		.loc 1 1547 0
 1362 009c BD46     		mov	sp, r7
 1363 009e 04B0     		add	sp, sp, #16
 1364              		@ sp needed
 1365 00a0 80BD     		pop	{r7, pc}
 1366              	.L101:
 1367 00a2 C046     		.align	2
 1368              	.L100:
 1369 00a4 00000000 		.word	UART_initVar
 1370 00a8 33000F40 		.word	1074724915
 1371 00ac 01000000 		.word	txPeriod.4874
 1372 00b0 42000F40 		.word	1074724930
 1373 00b4 62000F40 		.word	1074724962
 1374              		.cfi_endproc
 1375              	.LFE26:
 1376              		.size	UART_SendBreak, .-UART_SendBreak
 1377              		.section	.text.UART_SetTxAddressMode,"ax",%progbits
 1378              		.align	2
 1379              		.global	UART_SetTxAddressMode
 1380              		.code	16
 1381              		.thumb_func
 1382              		.type	UART_SetTxAddressMode, %function
 1383              	UART_SetTxAddressMode:
 1384              	.LFB27:
1548:.\Generated_Source\PSoC4/UART.c **** 
1549:.\Generated_Source\PSoC4/UART.c **** 
1550:.\Generated_Source\PSoC4/UART.c ****     /*******************************************************************************
1551:.\Generated_Source\PSoC4/UART.c ****     * Function Name: UART_SetTxAddressMode
1552:.\Generated_Source\PSoC4/UART.c ****     ********************************************************************************
1553:.\Generated_Source\PSoC4/UART.c ****     *
1554:.\Generated_Source\PSoC4/UART.c ****     * Summary:
1555:.\Generated_Source\PSoC4/UART.c ****     *  Configures the transmitter to signal the next bytes is address or data.
1556:.\Generated_Source\PSoC4/UART.c ****     *
1557:.\Generated_Source\PSoC4/UART.c ****     * Parameters:
1558:.\Generated_Source\PSoC4/UART.c ****     *  addressMode: 
1559:.\Generated_Source\PSoC4/UART.c ****     *       UART_SET_SPACE - Configure the transmitter to send the next
1560:.\Generated_Source\PSoC4/UART.c ****     *                                    byte as a data.
1561:.\Generated_Source\PSoC4/UART.c ****     *       UART_SET_MARK  - Configure the transmitter to send the next
1562:.\Generated_Source\PSoC4/UART.c ****     *                                    byte as an address.
1563:.\Generated_Source\PSoC4/UART.c ****     *
1564:.\Generated_Source\PSoC4/UART.c ****     * Return:
1565:.\Generated_Source\PSoC4/UART.c ****     *  None.
1566:.\Generated_Source\PSoC4/UART.c ****     *
1567:.\Generated_Source\PSoC4/UART.c ****     * Side Effects:
1568:.\Generated_Source\PSoC4/UART.c ****     *  This function sets and clears UART_CTRL_MARK bit in the Control
1569:.\Generated_Source\PSoC4/UART.c ****     *  register.
1570:.\Generated_Source\PSoC4/UART.c ****     *
1571:.\Generated_Source\PSoC4/UART.c ****     *******************************************************************************/
1572:.\Generated_Source\PSoC4/UART.c ****     void UART_SetTxAddressMode(uint8 addressMode) 
1573:.\Generated_Source\PSoC4/UART.c ****     {
 1385              		.loc 1 1573 0
 1386              		.cfi_startproc
 1387 0000 80B5     		push	{r7, lr}
 1388              		.cfi_def_cfa_offset 8
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 53


 1389              		.cfi_offset 7, -8
 1390              		.cfi_offset 14, -4
 1391 0002 82B0     		sub	sp, sp, #8
 1392              		.cfi_def_cfa_offset 16
 1393 0004 00AF     		add	r7, sp, #0
 1394              		.cfi_def_cfa_register 7
 1395 0006 021C     		mov	r2, r0
 1396 0008 FB1D     		add	r3, r7, #7
 1397 000a 1A70     		strb	r2, [r3]
1574:.\Generated_Source\PSoC4/UART.c ****         /* Mark/Space sending enable */
1575:.\Generated_Source\PSoC4/UART.c ****         if(addressMode != 0u)
1576:.\Generated_Source\PSoC4/UART.c ****         {
1577:.\Generated_Source\PSoC4/UART.c ****         #if( UART_CONTROL_REG_REMOVED == 0u )
1578:.\Generated_Source\PSoC4/UART.c ****             UART_WriteControlRegister(UART_ReadControlRegister() |
1579:.\Generated_Source\PSoC4/UART.c ****                                                   UART_CTRL_MARK);
1580:.\Generated_Source\PSoC4/UART.c ****         #endif /* End UART_CONTROL_REG_REMOVED == 0u */
1581:.\Generated_Source\PSoC4/UART.c ****         }
1582:.\Generated_Source\PSoC4/UART.c ****         else
1583:.\Generated_Source\PSoC4/UART.c ****         {
1584:.\Generated_Source\PSoC4/UART.c ****         #if( UART_CONTROL_REG_REMOVED == 0u )
1585:.\Generated_Source\PSoC4/UART.c ****             UART_WriteControlRegister(UART_ReadControlRegister() &
1586:.\Generated_Source\PSoC4/UART.c ****                                                   (uint8) ~UART_CTRL_MARK);
1587:.\Generated_Source\PSoC4/UART.c ****         #endif /* End UART_CONTROL_REG_REMOVED == 0u */
1588:.\Generated_Source\PSoC4/UART.c ****         }
1589:.\Generated_Source\PSoC4/UART.c ****     }
 1398              		.loc 1 1589 0
 1399 000c BD46     		mov	sp, r7
 1400 000e 02B0     		add	sp, sp, #8
 1401              		@ sp needed
 1402 0010 80BD     		pop	{r7, pc}
 1403              		.cfi_endproc
 1404              	.LFE27:
 1405              		.size	UART_SetTxAddressMode, .-UART_SetTxAddressMode
 1406 0012 C046     		.bss
 1407              	txPeriod.4874:
 1408 0001 00       		.space	1
 1409              		.text
 1410              	.Letext0:
 1411              		.file 2 ".\\Generated_Source\\PSoC4\\cytypes.h"
 1412              		.section	.debug_info,"",%progbits
 1413              	.Ldebug_info0:
 1414 0000 FC040000 		.4byte	0x4fc
 1415 0004 0400     		.2byte	0x4
 1416 0006 00000000 		.4byte	.Ldebug_abbrev0
 1417 000a 04       		.byte	0x4
 1418 000b 01       		.uleb128 0x1
 1419 000c 4E020000 		.4byte	.LASF60
 1420 0010 01       		.byte	0x1
 1421 0011 CE010000 		.4byte	.LASF61
 1422 0015 12000000 		.4byte	.LASF62
 1423 0019 00000000 		.4byte	.Ldebug_ranges0+0
 1424 001d 00000000 		.4byte	0
 1425 0021 00000000 		.4byte	.Ldebug_line0
 1426 0025 02       		.uleb128 0x2
 1427 0026 01       		.byte	0x1
 1428 0027 06       		.byte	0x6
 1429 0028 AF000000 		.4byte	.LASF0
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 54


 1430 002c 02       		.uleb128 0x2
 1431 002d 01       		.byte	0x1
 1432 002e 08       		.byte	0x8
 1433 002f FA020000 		.4byte	.LASF1
 1434 0033 02       		.uleb128 0x2
 1435 0034 02       		.byte	0x2
 1436 0035 05       		.byte	0x5
 1437 0036 19030000 		.4byte	.LASF2
 1438 003a 02       		.uleb128 0x2
 1439 003b 02       		.byte	0x2
 1440 003c 07       		.byte	0x7
 1441 003d 95010000 		.4byte	.LASF3
 1442 0041 02       		.uleb128 0x2
 1443 0042 04       		.byte	0x4
 1444 0043 05       		.byte	0x5
 1445 0044 C4000000 		.4byte	.LASF4
 1446 0048 02       		.uleb128 0x2
 1447 0049 04       		.byte	0x4
 1448 004a 07       		.byte	0x7
 1449 004b 70010000 		.4byte	.LASF5
 1450 004f 02       		.uleb128 0x2
 1451 0050 08       		.byte	0x8
 1452 0051 05       		.byte	0x5
 1453 0052 A1000000 		.4byte	.LASF6
 1454 0056 02       		.uleb128 0x2
 1455 0057 08       		.byte	0x8
 1456 0058 07       		.byte	0x7
 1457 0059 67000000 		.4byte	.LASF7
 1458 005d 03       		.uleb128 0x3
 1459 005e 04       		.byte	0x4
 1460 005f 05       		.byte	0x5
 1461 0060 696E7400 		.ascii	"int\000"
 1462 0064 02       		.uleb128 0x2
 1463 0065 04       		.byte	0x4
 1464 0066 07       		.byte	0x7
 1465 0067 43010000 		.4byte	.LASF8
 1466 006b 04       		.uleb128 0x4
 1467 006c EA000000 		.4byte	.LASF9
 1468 0070 02       		.byte	0x2
 1469 0071 B3       		.byte	0xb3
 1470 0072 2C000000 		.4byte	0x2c
 1471 0076 04       		.uleb128 0x4
 1472 0077 00000000 		.4byte	.LASF10
 1473 007b 02       		.byte	0x2
 1474 007c B4       		.byte	0xb4
 1475 007d 3A000000 		.4byte	0x3a
 1476 0081 02       		.uleb128 0x2
 1477 0082 04       		.byte	0x4
 1478 0083 04       		.byte	0x4
 1479 0084 48020000 		.4byte	.LASF11
 1480 0088 02       		.uleb128 0x2
 1481 0089 08       		.byte	0x8
 1482 008a 04       		.byte	0x4
 1483 008b 09010000 		.4byte	.LASF12
 1484 008f 04       		.uleb128 0x4
 1485 0090 66030000 		.4byte	.LASF13
 1486 0094 02       		.byte	0x2
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 55


 1487 0095 C4       		.byte	0xc4
 1488 0096 9A000000 		.4byte	0x9a
 1489 009a 02       		.uleb128 0x2
 1490 009b 01       		.byte	0x1
 1491 009c 08       		.byte	0x8
 1492 009d 61030000 		.4byte	.LASF14
 1493 00a1 05       		.uleb128 0x5
 1494 00a2 DF020000 		.4byte	.LASF15
 1495 00a6 02       		.byte	0x2
 1496 00a7 5D01     		.2byte	0x15d
 1497 00a9 AD000000 		.4byte	0xad
 1498 00ad 06       		.uleb128 0x6
 1499 00ae 6B000000 		.4byte	0x6b
 1500 00b2 02       		.uleb128 0x2
 1501 00b3 04       		.byte	0x4
 1502 00b4 07       		.byte	0x7
 1503 00b5 08020000 		.4byte	.LASF16
 1504 00b9 07       		.uleb128 0x7
 1505 00ba 7E000000 		.4byte	.LASF17
 1506 00be 01       		.byte	0x1
 1507 00bf 4C       		.byte	0x4c
 1508 00c0 00000000 		.4byte	.LFB1
 1509 00c4 24000000 		.4byte	.LFE1-.LFB1
 1510 00c8 01       		.uleb128 0x1
 1511 00c9 9C       		.byte	0x9c
 1512 00ca 08       		.uleb128 0x8
 1513 00cb 24010000 		.4byte	.LASF18
 1514 00cf 01       		.byte	0x1
 1515 00d0 6A       		.byte	0x6a
 1516 00d1 00000000 		.4byte	.LFB2
 1517 00d5 3C000000 		.4byte	.LFE2-.LFB2
 1518 00d9 01       		.uleb128 0x1
 1519 00da 9C       		.byte	0x9c
 1520 00db 09       		.uleb128 0x9
 1521 00dc 43030000 		.4byte	.LASF19
 1522 00e0 01       		.byte	0x1
 1523 00e1 B7       		.byte	0xb7
 1524 00e2 00000000 		.4byte	.LFB3
 1525 00e6 64000000 		.4byte	.LFE3-.LFB3
 1526 00ea 01       		.uleb128 0x1
 1527 00eb 9C       		.byte	0x9c
 1528 00ec FF000000 		.4byte	0xff
 1529 00f0 0A       		.uleb128 0xa
 1530 00f1 91030000 		.4byte	.LASF21
 1531 00f5 01       		.byte	0x1
 1532 00f6 B9       		.byte	0xb9
 1533 00f7 6B000000 		.4byte	0x6b
 1534 00fb 02       		.uleb128 0x2
 1535 00fc 91       		.byte	0x91
 1536 00fd 6F       		.sleb128 -17
 1537 00fe 00       		.byte	0
 1538 00ff 09       		.uleb128 0x9
 1539 0100 CB030000 		.4byte	.LASF20
 1540 0104 01       		.byte	0x1
 1541 0105 F0       		.byte	0xf0
 1542 0106 00000000 		.4byte	.LFB4
 1543 010a 60000000 		.4byte	.LFE4-.LFB4
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 56


 1544 010e 01       		.uleb128 0x1
 1545 010f 9C       		.byte	0x9c
 1546 0110 23010000 		.4byte	0x123
 1547 0114 0A       		.uleb128 0xa
 1548 0115 91030000 		.4byte	.LASF21
 1549 0119 01       		.byte	0x1
 1550 011a F2       		.byte	0xf2
 1551 011b 6B000000 		.4byte	0x6b
 1552 011f 02       		.uleb128 0x2
 1553 0120 91       		.byte	0x91
 1554 0121 6F       		.sleb128 -17
 1555 0122 00       		.byte	0
 1556 0123 0B       		.uleb128 0xb
 1557 0124 F0000000 		.4byte	.LASF32
 1558 0128 01       		.byte	0x1
 1559 0129 2701     		.2byte	0x127
 1560 012b 6B000000 		.4byte	0x6b
 1561 012f 00000000 		.4byte	.LFB5
 1562 0133 0C000000 		.4byte	.LFE5-.LFB5
 1563 0137 01       		.uleb128 0x1
 1564 0138 9C       		.byte	0x9c
 1565 0139 0C       		.uleb128 0xc
 1566 013a E4030000 		.4byte	.LASF22
 1567 013e 01       		.byte	0x1
 1568 013f 3F01     		.2byte	0x13f
 1569 0141 00000000 		.4byte	.LFB6
 1570 0145 12000000 		.4byte	.LFE6-.LFB6
 1571 0149 01       		.uleb128 0x1
 1572 014a 9C       		.byte	0x9c
 1573 014b 5F010000 		.4byte	0x15f
 1574 014f 0D       		.uleb128 0xd
 1575 0150 1C010000 		.4byte	.LASF24
 1576 0154 01       		.byte	0x1
 1577 0155 3F01     		.2byte	0x13f
 1578 0157 6B000000 		.4byte	0x6b
 1579 015b 02       		.uleb128 0x2
 1580 015c 91       		.byte	0x91
 1581 015d 77       		.sleb128 -9
 1582 015e 00       		.byte	0
 1583 015f 0C       		.uleb128 0xc
 1584 0160 6C030000 		.4byte	.LASF23
 1585 0164 01       		.byte	0x1
 1586 0165 6701     		.2byte	0x167
 1587 0167 00000000 		.4byte	.LFB7
 1588 016b 20000000 		.4byte	.LFE7-.LFB7
 1589 016f 01       		.uleb128 0x1
 1590 0170 9C       		.byte	0x9c
 1591 0171 85010000 		.4byte	0x185
 1592 0175 0D       		.uleb128 0xd
 1593 0176 B1010000 		.4byte	.LASF25
 1594 017a 01       		.byte	0x1
 1595 017b 6701     		.2byte	0x167
 1596 017d 6B000000 		.4byte	0x6b
 1597 0181 02       		.uleb128 0x2
 1598 0182 91       		.byte	0x91
 1599 0183 77       		.sleb128 -9
 1600 0184 00       		.byte	0
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 57


 1601 0185 0E       		.uleb128 0xe
 1602 0186 DA000000 		.4byte	.LASF27
 1603 018a 01       		.byte	0x1
 1604 018b 8801     		.2byte	0x188
 1605 018d 6B000000 		.4byte	0x6b
 1606 0191 00000000 		.4byte	.LFB8
 1607 0195 20000000 		.4byte	.LFE8-.LFB8
 1608 0199 01       		.uleb128 0x1
 1609 019a 9C       		.byte	0x9c
 1610 019b AF010000 		.4byte	0x1af
 1611 019f 0F       		.uleb128 0xf
 1612 01a0 3C030000 		.4byte	.LASF26
 1613 01a4 01       		.byte	0x1
 1614 01a5 8A01     		.2byte	0x18a
 1615 01a7 6B000000 		.4byte	0x6b
 1616 01ab 02       		.uleb128 0x2
 1617 01ac 91       		.byte	0x91
 1618 01ad 77       		.sleb128 -9
 1619 01ae 00       		.byte	0
 1620 01af 0E       		.uleb128 0xe
 1621 01b0 4F030000 		.4byte	.LASF28
 1622 01b4 01       		.byte	0x1
 1623 01b5 E501     		.2byte	0x1e5
 1624 01b7 6B000000 		.4byte	0x6b
 1625 01bb 00000000 		.4byte	.LFB9
 1626 01bf 24000000 		.4byte	.LFE9-.LFB9
 1627 01c3 01       		.uleb128 0x1
 1628 01c4 9C       		.byte	0x9c
 1629 01c5 D9010000 		.4byte	0x1d9
 1630 01c9 0F       		.uleb128 0xf
 1631 01ca C4030000 		.4byte	.LASF29
 1632 01ce 01       		.byte	0x1
 1633 01cf E701     		.2byte	0x1e7
 1634 01d1 6B000000 		.4byte	0x6b
 1635 01d5 02       		.uleb128 0x2
 1636 01d6 91       		.byte	0x91
 1637 01d7 77       		.sleb128 -9
 1638 01d8 00       		.byte	0
 1639 01d9 0E       		.uleb128 0xe
 1640 01da 84030000 		.4byte	.LASF30
 1641 01de 01       		.byte	0x1
 1642 01df 1402     		.2byte	0x214
 1643 01e1 6B000000 		.4byte	0x6b
 1644 01e5 00000000 		.4byte	.LFB10
 1645 01e9 4C000000 		.4byte	.LFE10-.LFB10
 1646 01ed 01       		.uleb128 0x1
 1647 01ee 9C       		.byte	0x9c
 1648 01ef 12020000 		.4byte	0x212
 1649 01f3 0F       		.uleb128 0xf
 1650 01f4 3C030000 		.4byte	.LASF26
 1651 01f8 01       		.byte	0x1
 1652 01f9 1602     		.2byte	0x216
 1653 01fb 6B000000 		.4byte	0x6b
 1654 01ff 02       		.uleb128 0x2
 1655 0200 91       		.byte	0x91
 1656 0201 77       		.sleb128 -9
 1657 0202 0F       		.uleb128 0xf
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 58


 1658 0203 3F020000 		.4byte	.LASF31
 1659 0207 01       		.byte	0x1
 1660 0208 1702     		.2byte	0x217
 1661 020a 6B000000 		.4byte	0x6b
 1662 020e 02       		.uleb128 0x2
 1663 020f 91       		.byte	0x91
 1664 0210 76       		.sleb128 -10
 1665 0211 00       		.byte	0
 1666 0212 10       		.uleb128 0x10
 1667 0213 36010000 		.4byte	.LASF33
 1668 0217 01       		.byte	0x1
 1669 0218 7A02     		.2byte	0x27a
 1670 021a 76000000 		.4byte	0x76
 1671 021e 00000000 		.4byte	.LFB11
 1672 0222 22000000 		.4byte	.LFE11-.LFB11
 1673 0226 01       		.uleb128 0x1
 1674 0227 9C       		.byte	0x9c
 1675 0228 0E       		.uleb128 0xe
 1676 0229 AF030000 		.4byte	.LASF34
 1677 022d 01       		.byte	0x1
 1678 022e AB02     		.2byte	0x2ab
 1679 0230 6B000000 		.4byte	0x6b
 1680 0234 00000000 		.4byte	.LFB12
 1681 0238 30000000 		.4byte	.LFE12-.LFB12
 1682 023c 01       		.uleb128 0x1
 1683 023d 9C       		.byte	0x9c
 1684 023e 52020000 		.4byte	0x252
 1685 0242 0F       		.uleb128 0xf
 1686 0243 90010000 		.4byte	.LASF35
 1687 0247 01       		.byte	0x1
 1688 0248 AE02     		.2byte	0x2ae
 1689 024a 6B000000 		.4byte	0x6b
 1690 024e 02       		.uleb128 0x2
 1691 024f 91       		.byte	0x91
 1692 0250 77       		.sleb128 -9
 1693 0251 00       		.byte	0
 1694 0252 11       		.uleb128 0x11
 1695 0253 FE030000 		.4byte	.LASF36
 1696 0257 01       		.byte	0x1
 1697 0258 F502     		.2byte	0x2f5
 1698 025a 00000000 		.4byte	.LFB13
 1699 025e 44000000 		.4byte	.LFE13-.LFB13
 1700 0262 01       		.uleb128 0x1
 1701 0263 9C       		.byte	0x9c
 1702 0264 78020000 		.4byte	0x278
 1703 0268 0F       		.uleb128 0xf
 1704 0269 91030000 		.4byte	.LASF21
 1705 026d 01       		.byte	0x1
 1706 026e F702     		.2byte	0x2f7
 1707 0270 6B000000 		.4byte	0x6b
 1708 0274 02       		.uleb128 0x2
 1709 0275 91       		.byte	0x91
 1710 0276 6F       		.sleb128 -17
 1711 0277 00       		.byte	0
 1712 0278 0C       		.uleb128 0xc
 1713 0279 E4020000 		.4byte	.LASF37
 1714 027d 01       		.byte	0x1
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 59


 1715 027e 2D03     		.2byte	0x32d
 1716 0280 00000000 		.4byte	.LFB14
 1717 0284 12000000 		.4byte	.LFE14-.LFB14
 1718 0288 01       		.uleb128 0x1
 1719 0289 9C       		.byte	0x9c
 1720 028a 9E020000 		.4byte	0x29e
 1721 028e 0D       		.uleb128 0xd
 1722 028f 10010000 		.4byte	.LASF38
 1723 0293 01       		.byte	0x1
 1724 0294 2D03     		.2byte	0x32d
 1725 0296 6B000000 		.4byte	0x6b
 1726 029a 02       		.uleb128 0x2
 1727 029b 91       		.byte	0x91
 1728 029c 77       		.sleb128 -9
 1729 029d 00       		.byte	0
 1730 029e 0C       		.uleb128 0xc
 1731 029f 19020000 		.4byte	.LASF39
 1732 02a3 01       		.byte	0x1
 1733 02a4 5903     		.2byte	0x359
 1734 02a6 00000000 		.4byte	.LFB15
 1735 02aa 20000000 		.4byte	.LFE15-.LFB15
 1736 02ae 01       		.uleb128 0x1
 1737 02af 9C       		.byte	0x9c
 1738 02b0 C4020000 		.4byte	0x2c4
 1739 02b4 0D       		.uleb128 0xd
 1740 02b5 11020000 		.4byte	.LASF40
 1741 02b9 01       		.byte	0x1
 1742 02ba 5903     		.2byte	0x359
 1743 02bc 6B000000 		.4byte	0x6b
 1744 02c0 02       		.uleb128 0x2
 1745 02c1 91       		.byte	0x91
 1746 02c2 77       		.sleb128 -9
 1747 02c3 00       		.byte	0
 1748 02c4 0C       		.uleb128 0xc
 1749 02c5 2C020000 		.4byte	.LASF41
 1750 02c9 01       		.byte	0x1
 1751 02ca 6D03     		.2byte	0x36d
 1752 02cc 00000000 		.4byte	.LFB16
 1753 02d0 20000000 		.4byte	.LFE16-.LFB16
 1754 02d4 01       		.uleb128 0x1
 1755 02d5 9C       		.byte	0x9c
 1756 02d6 EA020000 		.4byte	0x2ea
 1757 02da 0D       		.uleb128 0xd
 1758 02db 11020000 		.4byte	.LASF40
 1759 02df 01       		.byte	0x1
 1760 02e0 6D03     		.2byte	0x36d
 1761 02e2 6B000000 		.4byte	0x6b
 1762 02e6 02       		.uleb128 0x2
 1763 02e7 91       		.byte	0x91
 1764 02e8 77       		.sleb128 -9
 1765 02e9 00       		.byte	0
 1766 02ea 0C       		.uleb128 0xc
 1767 02eb 89000000 		.4byte	.LASF42
 1768 02ef 01       		.byte	0x1
 1769 02f0 8C03     		.2byte	0x38c
 1770 02f2 00000000 		.4byte	.LFB17
 1771 02f6 20000000 		.4byte	.LFE17-.LFB17
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 60


 1772 02fa 01       		.uleb128 0x1
 1773 02fb 9C       		.byte	0x9c
 1774 02fc 10030000 		.4byte	0x310
 1775 0300 0D       		.uleb128 0xd
 1776 0301 B1010000 		.4byte	.LASF25
 1777 0305 01       		.byte	0x1
 1778 0306 8C03     		.2byte	0x38c
 1779 0308 6B000000 		.4byte	0x6b
 1780 030c 02       		.uleb128 0x2
 1781 030d 91       		.byte	0x91
 1782 030e 77       		.sleb128 -9
 1783 030f 00       		.byte	0
 1784 0310 0C       		.uleb128 0xc
 1785 0311 08030000 		.4byte	.LASF43
 1786 0315 01       		.byte	0x1
 1787 0316 AE03     		.2byte	0x3ae
 1788 0318 00000000 		.4byte	.LFB18
 1789 031c 2C000000 		.4byte	.LFE18-.LFB18
 1790 0320 01       		.uleb128 0x1
 1791 0321 9C       		.byte	0x9c
 1792 0322 36030000 		.4byte	0x336
 1793 0326 0D       		.uleb128 0xd
 1794 0327 07000000 		.4byte	.LASF44
 1795 032b 01       		.byte	0x1
 1796 032c AE03     		.2byte	0x3ae
 1797 032e 6B000000 		.4byte	0x6b
 1798 0332 02       		.uleb128 0x2
 1799 0333 91       		.byte	0x91
 1800 0334 77       		.sleb128 -9
 1801 0335 00       		.byte	0
 1802 0336 0B       		.uleb128 0xb
 1803 0337 EE010000 		.4byte	.LASF45
 1804 033b 01       		.byte	0x1
 1805 033c EB03     		.2byte	0x3eb
 1806 033e 6B000000 		.4byte	0x6b
 1807 0342 00000000 		.4byte	.LFB19
 1808 0346 14000000 		.4byte	.LFE19-.LFB19
 1809 034a 01       		.uleb128 0x1
 1810 034b 9C       		.byte	0x9c
 1811 034c 0C       		.uleb128 0xc
 1812 034d CD000000 		.4byte	.LASF46
 1813 0351 01       		.byte	0x1
 1814 0352 1104     		.2byte	0x411
 1815 0354 00000000 		.4byte	.LFB20
 1816 0358 34000000 		.4byte	.LFE20-.LFB20
 1817 035c 01       		.uleb128 0x1
 1818 035d 9C       		.byte	0x9c
 1819 035e 72030000 		.4byte	0x372
 1820 0362 0D       		.uleb128 0xd
 1821 0363 07000000 		.4byte	.LASF44
 1822 0367 01       		.byte	0x1
 1823 0368 1104     		.2byte	0x411
 1824 036a 6B000000 		.4byte	0x6b
 1825 036e 02       		.uleb128 0x2
 1826 036f 91       		.byte	0x91
 1827 0370 77       		.sleb128 -9
 1828 0371 00       		.byte	0
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 61


 1829 0372 11       		.uleb128 0x11
 1830 0373 D5030000 		.4byte	.LASF47
 1831 0377 01       		.byte	0x1
 1832 0378 7904     		.2byte	0x479
 1833 037a 00000000 		.4byte	.LFB21
 1834 037e 54000000 		.4byte	.LFE21-.LFB21
 1835 0382 01       		.uleb128 0x1
 1836 0383 9C       		.byte	0x9c
 1837 0384 A7030000 		.4byte	0x3a7
 1838 0388 0D       		.uleb128 0xd
 1839 0389 60000000 		.4byte	.LASF48
 1840 038d 01       		.byte	0x1
 1841 038e 7904     		.2byte	0x479
 1842 0390 A7030000 		.4byte	0x3a7
 1843 0394 02       		.uleb128 0x2
 1844 0395 91       		.byte	0x91
 1845 0396 6C       		.sleb128 -20
 1846 0397 0F       		.uleb128 0xf
 1847 0398 A8010000 		.4byte	.LASF49
 1848 039c 01       		.byte	0x1
 1849 039d 7B04     		.2byte	0x47b
 1850 039f 76000000 		.4byte	0x76
 1851 03a3 02       		.uleb128 0x2
 1852 03a4 91       		.byte	0x91
 1853 03a5 76       		.sleb128 -10
 1854 03a6 00       		.byte	0
 1855 03a7 12       		.uleb128 0x12
 1856 03a8 04       		.byte	0x4
 1857 03a9 AD030000 		.4byte	0x3ad
 1858 03ad 13       		.uleb128 0x13
 1859 03ae 8F000000 		.4byte	0x8f
 1860 03b2 11       		.uleb128 0x11
 1861 03b3 82010000 		.4byte	.LASF50
 1862 03b7 01       		.byte	0x1
 1863 03b8 A704     		.2byte	0x4a7
 1864 03ba 00000000 		.4byte	.LFB22
 1865 03be 58000000 		.4byte	.LFE22-.LFB22
 1866 03c2 01       		.uleb128 0x1
 1867 03c3 9C       		.byte	0x9c
 1868 03c4 F6030000 		.4byte	0x3f6
 1869 03c8 0D       		.uleb128 0xd
 1870 03c9 60000000 		.4byte	.LASF48
 1871 03cd 01       		.byte	0x1
 1872 03ce A704     		.2byte	0x4a7
 1873 03d0 F6030000 		.4byte	0x3f6
 1874 03d4 02       		.uleb128 0x2
 1875 03d5 91       		.byte	0x91
 1876 03d6 6C       		.sleb128 -20
 1877 03d7 0D       		.uleb128 0xd
 1878 03d8 32030000 		.4byte	.LASF51
 1879 03dc 01       		.byte	0x1
 1880 03dd A704     		.2byte	0x4a7
 1881 03df 6B000000 		.4byte	0x6b
 1882 03e3 02       		.uleb128 0x2
 1883 03e4 91       		.byte	0x91
 1884 03e5 6B       		.sleb128 -21
 1885 03e6 0F       		.uleb128 0xf
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 62


 1886 03e7 A8010000 		.4byte	.LASF49
 1887 03eb 01       		.byte	0x1
 1888 03ec AA04     		.2byte	0x4aa
 1889 03ee 6B000000 		.4byte	0x6b
 1890 03f2 02       		.uleb128 0x2
 1891 03f3 91       		.byte	0x91
 1892 03f4 77       		.sleb128 -9
 1893 03f5 00       		.byte	0
 1894 03f6 12       		.uleb128 0x12
 1895 03f7 04       		.byte	0x4
 1896 03f8 FC030000 		.4byte	0x3fc
 1897 03fc 13       		.uleb128 0x13
 1898 03fd 6B000000 		.4byte	0x6b
 1899 0401 11       		.uleb128 0x11
 1900 0402 63010000 		.4byte	.LASF52
 1901 0406 01       		.byte	0x1
 1902 0407 CE04     		.2byte	0x4ce
 1903 0409 00000000 		.4byte	.LFB23
 1904 040d 34000000 		.4byte	.LFE23-.LFB23
 1905 0411 01       		.uleb128 0x1
 1906 0412 9C       		.byte	0x9c
 1907 0413 27040000 		.4byte	0x427
 1908 0417 0D       		.uleb128 0xd
 1909 0418 07000000 		.4byte	.LASF44
 1910 041c 01       		.byte	0x1
 1911 041d CE04     		.2byte	0x4ce
 1912 041f 6B000000 		.4byte	0x6b
 1913 0423 02       		.uleb128 0x2
 1914 0424 91       		.byte	0x91
 1915 0425 77       		.sleb128 -9
 1916 0426 00       		.byte	0
 1917 0427 0E       		.uleb128 0xe
 1918 0428 CA020000 		.4byte	.LASF53
 1919 042c 01       		.byte	0x1
 1920 042d F904     		.2byte	0x4f9
 1921 042f 6B000000 		.4byte	0x6b
 1922 0433 00000000 		.4byte	.LFB24
 1923 0437 48000000 		.4byte	.LFE24-.LFB24
 1924 043b 01       		.uleb128 0x1
 1925 043c 9C       		.byte	0x9c
 1926 043d 51040000 		.4byte	0x451
 1927 0441 0F       		.uleb128 0xf
 1928 0442 90010000 		.4byte	.LASF35
 1929 0446 01       		.byte	0x1
 1930 0447 FC04     		.2byte	0x4fc
 1931 0449 6B000000 		.4byte	0x6b
 1932 044d 02       		.uleb128 0x2
 1933 044e 91       		.byte	0x91
 1934 044f 77       		.sleb128 -9
 1935 0450 00       		.byte	0
 1936 0451 11       		.uleb128 0x11
 1937 0452 50010000 		.4byte	.LASF54
 1938 0456 01       		.byte	0x1
 1939 0457 4A05     		.2byte	0x54a
 1940 0459 00000000 		.4byte	.LFB25
 1941 045d 44000000 		.4byte	.LFE25-.LFB25
 1942 0461 01       		.uleb128 0x1
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 63


 1943 0462 9C       		.byte	0x9c
 1944 0463 77040000 		.4byte	0x477
 1945 0467 0F       		.uleb128 0xf
 1946 0468 91030000 		.4byte	.LASF21
 1947 046c 01       		.byte	0x1
 1948 046d 4C05     		.2byte	0x54c
 1949 046f 6B000000 		.4byte	0x6b
 1950 0473 02       		.uleb128 0x2
 1951 0474 91       		.byte	0x91
 1952 0475 6F       		.sleb128 -17
 1953 0476 00       		.byte	0
 1954 0477 0C       		.uleb128 0xc
 1955 0478 23030000 		.4byte	.LASF55
 1956 047c 01       		.byte	0x1
 1957 047d A005     		.2byte	0x5a0
 1958 047f 00000000 		.4byte	.LFB26
 1959 0483 B8000000 		.4byte	.LFE26-.LFB26
 1960 0487 01       		.uleb128 0x1
 1961 0488 9C       		.byte	0x9c
 1962 0489 C8040000 		.4byte	0x4c8
 1963 048d 0D       		.uleb128 0xd
 1964 048e 2E010000 		.4byte	.LASF56
 1965 0492 01       		.byte	0x1
 1966 0493 A005     		.2byte	0x5a0
 1967 0495 6B000000 		.4byte	0x6b
 1968 0499 02       		.uleb128 0x2
 1969 049a 91       		.byte	0x91
 1970 049b 6F       		.sleb128 -17
 1971 049c 14       		.uleb128 0x14
 1972 049d 14000000 		.4byte	.LBB2
 1973 04a1 88000000 		.4byte	.LBE2-.LBB2
 1974 04a5 0F       		.uleb128 0xf
 1975 04a6 00020000 		.4byte	.LASF57
 1976 04aa 01       		.byte	0x1
 1977 04ab A805     		.2byte	0x5a8
 1978 04ad 6B000000 		.4byte	0x6b
 1979 04b1 02       		.uleb128 0x2
 1980 04b2 91       		.byte	0x91
 1981 04b3 77       		.sleb128 -9
 1982 04b4 0F       		.uleb128 0xf
 1983 04b5 BB000000 		.4byte	.LASF58
 1984 04b9 01       		.byte	0x1
 1985 04ba D005     		.2byte	0x5d0
 1986 04bc 6B000000 		.4byte	0x6b
 1987 04c0 05       		.uleb128 0x5
 1988 04c1 03       		.byte	0x3
 1989 04c2 01000000 		.4byte	txPeriod.4874
 1990 04c6 00       		.byte	0
 1991 04c7 00       		.byte	0
 1992 04c8 0C       		.uleb128 0xc
 1993 04c9 B8010000 		.4byte	.LASF59
 1994 04cd 01       		.byte	0x1
 1995 04ce 2406     		.2byte	0x624
 1996 04d0 00000000 		.4byte	.LFB27
 1997 04d4 12000000 		.4byte	.LFE27-.LFB27
 1998 04d8 01       		.uleb128 0x1
 1999 04d9 9C       		.byte	0x9c
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 64


 2000 04da EE040000 		.4byte	0x4ee
 2001 04de 0D       		.uleb128 0xd
 2002 04df 10010000 		.4byte	.LASF38
 2003 04e3 01       		.byte	0x1
 2004 04e4 2406     		.2byte	0x624
 2005 04e6 6B000000 		.4byte	0x6b
 2006 04ea 02       		.uleb128 0x2
 2007 04eb 91       		.byte	0x91
 2008 04ec 77       		.sleb128 -9
 2009 04ed 00       		.byte	0
 2010 04ee 15       		.uleb128 0x15
 2011 04ef A2030000 		.4byte	.LASF63
 2012 04f3 01       		.byte	0x1
 2013 04f4 1B       		.byte	0x1b
 2014 04f5 6B000000 		.4byte	0x6b
 2015 04f9 05       		.uleb128 0x5
 2016 04fa 03       		.byte	0x3
 2017 04fb 00000000 		.4byte	UART_initVar
 2018 04ff 00       		.byte	0
 2019              		.section	.debug_abbrev,"",%progbits
 2020              	.Ldebug_abbrev0:
 2021 0000 01       		.uleb128 0x1
 2022 0001 11       		.uleb128 0x11
 2023 0002 01       		.byte	0x1
 2024 0003 25       		.uleb128 0x25
 2025 0004 0E       		.uleb128 0xe
 2026 0005 13       		.uleb128 0x13
 2027 0006 0B       		.uleb128 0xb
 2028 0007 03       		.uleb128 0x3
 2029 0008 0E       		.uleb128 0xe
 2030 0009 1B       		.uleb128 0x1b
 2031 000a 0E       		.uleb128 0xe
 2032 000b 55       		.uleb128 0x55
 2033 000c 17       		.uleb128 0x17
 2034 000d 11       		.uleb128 0x11
 2035 000e 01       		.uleb128 0x1
 2036 000f 10       		.uleb128 0x10
 2037 0010 17       		.uleb128 0x17
 2038 0011 00       		.byte	0
 2039 0012 00       		.byte	0
 2040 0013 02       		.uleb128 0x2
 2041 0014 24       		.uleb128 0x24
 2042 0015 00       		.byte	0
 2043 0016 0B       		.uleb128 0xb
 2044 0017 0B       		.uleb128 0xb
 2045 0018 3E       		.uleb128 0x3e
 2046 0019 0B       		.uleb128 0xb
 2047 001a 03       		.uleb128 0x3
 2048 001b 0E       		.uleb128 0xe
 2049 001c 00       		.byte	0
 2050 001d 00       		.byte	0
 2051 001e 03       		.uleb128 0x3
 2052 001f 24       		.uleb128 0x24
 2053 0020 00       		.byte	0
 2054 0021 0B       		.uleb128 0xb
 2055 0022 0B       		.uleb128 0xb
 2056 0023 3E       		.uleb128 0x3e
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 65


 2057 0024 0B       		.uleb128 0xb
 2058 0025 03       		.uleb128 0x3
 2059 0026 08       		.uleb128 0x8
 2060 0027 00       		.byte	0
 2061 0028 00       		.byte	0
 2062 0029 04       		.uleb128 0x4
 2063 002a 16       		.uleb128 0x16
 2064 002b 00       		.byte	0
 2065 002c 03       		.uleb128 0x3
 2066 002d 0E       		.uleb128 0xe
 2067 002e 3A       		.uleb128 0x3a
 2068 002f 0B       		.uleb128 0xb
 2069 0030 3B       		.uleb128 0x3b
 2070 0031 0B       		.uleb128 0xb
 2071 0032 49       		.uleb128 0x49
 2072 0033 13       		.uleb128 0x13
 2073 0034 00       		.byte	0
 2074 0035 00       		.byte	0
 2075 0036 05       		.uleb128 0x5
 2076 0037 16       		.uleb128 0x16
 2077 0038 00       		.byte	0
 2078 0039 03       		.uleb128 0x3
 2079 003a 0E       		.uleb128 0xe
 2080 003b 3A       		.uleb128 0x3a
 2081 003c 0B       		.uleb128 0xb
 2082 003d 3B       		.uleb128 0x3b
 2083 003e 05       		.uleb128 0x5
 2084 003f 49       		.uleb128 0x49
 2085 0040 13       		.uleb128 0x13
 2086 0041 00       		.byte	0
 2087 0042 00       		.byte	0
 2088 0043 06       		.uleb128 0x6
 2089 0044 35       		.uleb128 0x35
 2090 0045 00       		.byte	0
 2091 0046 49       		.uleb128 0x49
 2092 0047 13       		.uleb128 0x13
 2093 0048 00       		.byte	0
 2094 0049 00       		.byte	0
 2095 004a 07       		.uleb128 0x7
 2096 004b 2E       		.uleb128 0x2e
 2097 004c 00       		.byte	0
 2098 004d 3F       		.uleb128 0x3f
 2099 004e 19       		.uleb128 0x19
 2100 004f 03       		.uleb128 0x3
 2101 0050 0E       		.uleb128 0xe
 2102 0051 3A       		.uleb128 0x3a
 2103 0052 0B       		.uleb128 0xb
 2104 0053 3B       		.uleb128 0x3b
 2105 0054 0B       		.uleb128 0xb
 2106 0055 27       		.uleb128 0x27
 2107 0056 19       		.uleb128 0x19
 2108 0057 11       		.uleb128 0x11
 2109 0058 01       		.uleb128 0x1
 2110 0059 12       		.uleb128 0x12
 2111 005a 06       		.uleb128 0x6
 2112 005b 40       		.uleb128 0x40
 2113 005c 18       		.uleb128 0x18
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 66


 2114 005d 9642     		.uleb128 0x2116
 2115 005f 19       		.uleb128 0x19
 2116 0060 00       		.byte	0
 2117 0061 00       		.byte	0
 2118 0062 08       		.uleb128 0x8
 2119 0063 2E       		.uleb128 0x2e
 2120 0064 00       		.byte	0
 2121 0065 3F       		.uleb128 0x3f
 2122 0066 19       		.uleb128 0x19
 2123 0067 03       		.uleb128 0x3
 2124 0068 0E       		.uleb128 0xe
 2125 0069 3A       		.uleb128 0x3a
 2126 006a 0B       		.uleb128 0xb
 2127 006b 3B       		.uleb128 0x3b
 2128 006c 0B       		.uleb128 0xb
 2129 006d 27       		.uleb128 0x27
 2130 006e 19       		.uleb128 0x19
 2131 006f 11       		.uleb128 0x11
 2132 0070 01       		.uleb128 0x1
 2133 0071 12       		.uleb128 0x12
 2134 0072 06       		.uleb128 0x6
 2135 0073 40       		.uleb128 0x40
 2136 0074 18       		.uleb128 0x18
 2137 0075 9742     		.uleb128 0x2117
 2138 0077 19       		.uleb128 0x19
 2139 0078 00       		.byte	0
 2140 0079 00       		.byte	0
 2141 007a 09       		.uleb128 0x9
 2142 007b 2E       		.uleb128 0x2e
 2143 007c 01       		.byte	0x1
 2144 007d 3F       		.uleb128 0x3f
 2145 007e 19       		.uleb128 0x19
 2146 007f 03       		.uleb128 0x3
 2147 0080 0E       		.uleb128 0xe
 2148 0081 3A       		.uleb128 0x3a
 2149 0082 0B       		.uleb128 0xb
 2150 0083 3B       		.uleb128 0x3b
 2151 0084 0B       		.uleb128 0xb
 2152 0085 27       		.uleb128 0x27
 2153 0086 19       		.uleb128 0x19
 2154 0087 11       		.uleb128 0x11
 2155 0088 01       		.uleb128 0x1
 2156 0089 12       		.uleb128 0x12
 2157 008a 06       		.uleb128 0x6
 2158 008b 40       		.uleb128 0x40
 2159 008c 18       		.uleb128 0x18
 2160 008d 9642     		.uleb128 0x2116
 2161 008f 19       		.uleb128 0x19
 2162 0090 01       		.uleb128 0x1
 2163 0091 13       		.uleb128 0x13
 2164 0092 00       		.byte	0
 2165 0093 00       		.byte	0
 2166 0094 0A       		.uleb128 0xa
 2167 0095 34       		.uleb128 0x34
 2168 0096 00       		.byte	0
 2169 0097 03       		.uleb128 0x3
 2170 0098 0E       		.uleb128 0xe
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 67


 2171 0099 3A       		.uleb128 0x3a
 2172 009a 0B       		.uleb128 0xb
 2173 009b 3B       		.uleb128 0x3b
 2174 009c 0B       		.uleb128 0xb
 2175 009d 49       		.uleb128 0x49
 2176 009e 13       		.uleb128 0x13
 2177 009f 02       		.uleb128 0x2
 2178 00a0 18       		.uleb128 0x18
 2179 00a1 00       		.byte	0
 2180 00a2 00       		.byte	0
 2181 00a3 0B       		.uleb128 0xb
 2182 00a4 2E       		.uleb128 0x2e
 2183 00a5 00       		.byte	0
 2184 00a6 3F       		.uleb128 0x3f
 2185 00a7 19       		.uleb128 0x19
 2186 00a8 03       		.uleb128 0x3
 2187 00a9 0E       		.uleb128 0xe
 2188 00aa 3A       		.uleb128 0x3a
 2189 00ab 0B       		.uleb128 0xb
 2190 00ac 3B       		.uleb128 0x3b
 2191 00ad 05       		.uleb128 0x5
 2192 00ae 27       		.uleb128 0x27
 2193 00af 19       		.uleb128 0x19
 2194 00b0 49       		.uleb128 0x49
 2195 00b1 13       		.uleb128 0x13
 2196 00b2 11       		.uleb128 0x11
 2197 00b3 01       		.uleb128 0x1
 2198 00b4 12       		.uleb128 0x12
 2199 00b5 06       		.uleb128 0x6
 2200 00b6 40       		.uleb128 0x40
 2201 00b7 18       		.uleb128 0x18
 2202 00b8 9742     		.uleb128 0x2117
 2203 00ba 19       		.uleb128 0x19
 2204 00bb 00       		.byte	0
 2205 00bc 00       		.byte	0
 2206 00bd 0C       		.uleb128 0xc
 2207 00be 2E       		.uleb128 0x2e
 2208 00bf 01       		.byte	0x1
 2209 00c0 3F       		.uleb128 0x3f
 2210 00c1 19       		.uleb128 0x19
 2211 00c2 03       		.uleb128 0x3
 2212 00c3 0E       		.uleb128 0xe
 2213 00c4 3A       		.uleb128 0x3a
 2214 00c5 0B       		.uleb128 0xb
 2215 00c6 3B       		.uleb128 0x3b
 2216 00c7 05       		.uleb128 0x5
 2217 00c8 27       		.uleb128 0x27
 2218 00c9 19       		.uleb128 0x19
 2219 00ca 11       		.uleb128 0x11
 2220 00cb 01       		.uleb128 0x1
 2221 00cc 12       		.uleb128 0x12
 2222 00cd 06       		.uleb128 0x6
 2223 00ce 40       		.uleb128 0x40
 2224 00cf 18       		.uleb128 0x18
 2225 00d0 9742     		.uleb128 0x2117
 2226 00d2 19       		.uleb128 0x19
 2227 00d3 01       		.uleb128 0x1
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 68


 2228 00d4 13       		.uleb128 0x13
 2229 00d5 00       		.byte	0
 2230 00d6 00       		.byte	0
 2231 00d7 0D       		.uleb128 0xd
 2232 00d8 05       		.uleb128 0x5
 2233 00d9 00       		.byte	0
 2234 00da 03       		.uleb128 0x3
 2235 00db 0E       		.uleb128 0xe
 2236 00dc 3A       		.uleb128 0x3a
 2237 00dd 0B       		.uleb128 0xb
 2238 00de 3B       		.uleb128 0x3b
 2239 00df 05       		.uleb128 0x5
 2240 00e0 49       		.uleb128 0x49
 2241 00e1 13       		.uleb128 0x13
 2242 00e2 02       		.uleb128 0x2
 2243 00e3 18       		.uleb128 0x18
 2244 00e4 00       		.byte	0
 2245 00e5 00       		.byte	0
 2246 00e6 0E       		.uleb128 0xe
 2247 00e7 2E       		.uleb128 0x2e
 2248 00e8 01       		.byte	0x1
 2249 00e9 3F       		.uleb128 0x3f
 2250 00ea 19       		.uleb128 0x19
 2251 00eb 03       		.uleb128 0x3
 2252 00ec 0E       		.uleb128 0xe
 2253 00ed 3A       		.uleb128 0x3a
 2254 00ee 0B       		.uleb128 0xb
 2255 00ef 3B       		.uleb128 0x3b
 2256 00f0 05       		.uleb128 0x5
 2257 00f1 27       		.uleb128 0x27
 2258 00f2 19       		.uleb128 0x19
 2259 00f3 49       		.uleb128 0x49
 2260 00f4 13       		.uleb128 0x13
 2261 00f5 11       		.uleb128 0x11
 2262 00f6 01       		.uleb128 0x1
 2263 00f7 12       		.uleb128 0x12
 2264 00f8 06       		.uleb128 0x6
 2265 00f9 40       		.uleb128 0x40
 2266 00fa 18       		.uleb128 0x18
 2267 00fb 9742     		.uleb128 0x2117
 2268 00fd 19       		.uleb128 0x19
 2269 00fe 01       		.uleb128 0x1
 2270 00ff 13       		.uleb128 0x13
 2271 0100 00       		.byte	0
 2272 0101 00       		.byte	0
 2273 0102 0F       		.uleb128 0xf
 2274 0103 34       		.uleb128 0x34
 2275 0104 00       		.byte	0
 2276 0105 03       		.uleb128 0x3
 2277 0106 0E       		.uleb128 0xe
 2278 0107 3A       		.uleb128 0x3a
 2279 0108 0B       		.uleb128 0xb
 2280 0109 3B       		.uleb128 0x3b
 2281 010a 05       		.uleb128 0x5
 2282 010b 49       		.uleb128 0x49
 2283 010c 13       		.uleb128 0x13
 2284 010d 02       		.uleb128 0x2
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 69


 2285 010e 18       		.uleb128 0x18
 2286 010f 00       		.byte	0
 2287 0110 00       		.byte	0
 2288 0111 10       		.uleb128 0x10
 2289 0112 2E       		.uleb128 0x2e
 2290 0113 00       		.byte	0
 2291 0114 3F       		.uleb128 0x3f
 2292 0115 19       		.uleb128 0x19
 2293 0116 03       		.uleb128 0x3
 2294 0117 0E       		.uleb128 0xe
 2295 0118 3A       		.uleb128 0x3a
 2296 0119 0B       		.uleb128 0xb
 2297 011a 3B       		.uleb128 0x3b
 2298 011b 05       		.uleb128 0x5
 2299 011c 27       		.uleb128 0x27
 2300 011d 19       		.uleb128 0x19
 2301 011e 49       		.uleb128 0x49
 2302 011f 13       		.uleb128 0x13
 2303 0120 11       		.uleb128 0x11
 2304 0121 01       		.uleb128 0x1
 2305 0122 12       		.uleb128 0x12
 2306 0123 06       		.uleb128 0x6
 2307 0124 40       		.uleb128 0x40
 2308 0125 18       		.uleb128 0x18
 2309 0126 9642     		.uleb128 0x2116
 2310 0128 19       		.uleb128 0x19
 2311 0129 00       		.byte	0
 2312 012a 00       		.byte	0
 2313 012b 11       		.uleb128 0x11
 2314 012c 2E       		.uleb128 0x2e
 2315 012d 01       		.byte	0x1
 2316 012e 3F       		.uleb128 0x3f
 2317 012f 19       		.uleb128 0x19
 2318 0130 03       		.uleb128 0x3
 2319 0131 0E       		.uleb128 0xe
 2320 0132 3A       		.uleb128 0x3a
 2321 0133 0B       		.uleb128 0xb
 2322 0134 3B       		.uleb128 0x3b
 2323 0135 05       		.uleb128 0x5
 2324 0136 27       		.uleb128 0x27
 2325 0137 19       		.uleb128 0x19
 2326 0138 11       		.uleb128 0x11
 2327 0139 01       		.uleb128 0x1
 2328 013a 12       		.uleb128 0x12
 2329 013b 06       		.uleb128 0x6
 2330 013c 40       		.uleb128 0x40
 2331 013d 18       		.uleb128 0x18
 2332 013e 9642     		.uleb128 0x2116
 2333 0140 19       		.uleb128 0x19
 2334 0141 01       		.uleb128 0x1
 2335 0142 13       		.uleb128 0x13
 2336 0143 00       		.byte	0
 2337 0144 00       		.byte	0
 2338 0145 12       		.uleb128 0x12
 2339 0146 0F       		.uleb128 0xf
 2340 0147 00       		.byte	0
 2341 0148 0B       		.uleb128 0xb
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 70


 2342 0149 0B       		.uleb128 0xb
 2343 014a 49       		.uleb128 0x49
 2344 014b 13       		.uleb128 0x13
 2345 014c 00       		.byte	0
 2346 014d 00       		.byte	0
 2347 014e 13       		.uleb128 0x13
 2348 014f 26       		.uleb128 0x26
 2349 0150 00       		.byte	0
 2350 0151 49       		.uleb128 0x49
 2351 0152 13       		.uleb128 0x13
 2352 0153 00       		.byte	0
 2353 0154 00       		.byte	0
 2354 0155 14       		.uleb128 0x14
 2355 0156 0B       		.uleb128 0xb
 2356 0157 01       		.byte	0x1
 2357 0158 11       		.uleb128 0x11
 2358 0159 01       		.uleb128 0x1
 2359 015a 12       		.uleb128 0x12
 2360 015b 06       		.uleb128 0x6
 2361 015c 00       		.byte	0
 2362 015d 00       		.byte	0
 2363 015e 15       		.uleb128 0x15
 2364 015f 34       		.uleb128 0x34
 2365 0160 00       		.byte	0
 2366 0161 03       		.uleb128 0x3
 2367 0162 0E       		.uleb128 0xe
 2368 0163 3A       		.uleb128 0x3a
 2369 0164 0B       		.uleb128 0xb
 2370 0165 3B       		.uleb128 0x3b
 2371 0166 0B       		.uleb128 0xb
 2372 0167 49       		.uleb128 0x49
 2373 0168 13       		.uleb128 0x13
 2374 0169 3F       		.uleb128 0x3f
 2375 016a 19       		.uleb128 0x19
 2376 016b 02       		.uleb128 0x2
 2377 016c 18       		.uleb128 0x18
 2378 016d 00       		.byte	0
 2379 016e 00       		.byte	0
 2380 016f 00       		.byte	0
 2381              		.section	.debug_aranges,"",%progbits
 2382 0000 EC000000 		.4byte	0xec
 2383 0004 0200     		.2byte	0x2
 2384 0006 00000000 		.4byte	.Ldebug_info0
 2385 000a 04       		.byte	0x4
 2386 000b 00       		.byte	0
 2387 000c 0000     		.2byte	0
 2388 000e 0000     		.2byte	0
 2389 0010 00000000 		.4byte	.LFB1
 2390 0014 24000000 		.4byte	.LFE1-.LFB1
 2391 0018 00000000 		.4byte	.LFB2
 2392 001c 3C000000 		.4byte	.LFE2-.LFB2
 2393 0020 00000000 		.4byte	.LFB3
 2394 0024 64000000 		.4byte	.LFE3-.LFB3
 2395 0028 00000000 		.4byte	.LFB4
 2396 002c 60000000 		.4byte	.LFE4-.LFB4
 2397 0030 00000000 		.4byte	.LFB5
 2398 0034 0C000000 		.4byte	.LFE5-.LFB5
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 71


 2399 0038 00000000 		.4byte	.LFB6
 2400 003c 12000000 		.4byte	.LFE6-.LFB6
 2401 0040 00000000 		.4byte	.LFB7
 2402 0044 20000000 		.4byte	.LFE7-.LFB7
 2403 0048 00000000 		.4byte	.LFB8
 2404 004c 20000000 		.4byte	.LFE8-.LFB8
 2405 0050 00000000 		.4byte	.LFB9
 2406 0054 24000000 		.4byte	.LFE9-.LFB9
 2407 0058 00000000 		.4byte	.LFB10
 2408 005c 4C000000 		.4byte	.LFE10-.LFB10
 2409 0060 00000000 		.4byte	.LFB11
 2410 0064 22000000 		.4byte	.LFE11-.LFB11
 2411 0068 00000000 		.4byte	.LFB12
 2412 006c 30000000 		.4byte	.LFE12-.LFB12
 2413 0070 00000000 		.4byte	.LFB13
 2414 0074 44000000 		.4byte	.LFE13-.LFB13
 2415 0078 00000000 		.4byte	.LFB14
 2416 007c 12000000 		.4byte	.LFE14-.LFB14
 2417 0080 00000000 		.4byte	.LFB15
 2418 0084 20000000 		.4byte	.LFE15-.LFB15
 2419 0088 00000000 		.4byte	.LFB16
 2420 008c 20000000 		.4byte	.LFE16-.LFB16
 2421 0090 00000000 		.4byte	.LFB17
 2422 0094 20000000 		.4byte	.LFE17-.LFB17
 2423 0098 00000000 		.4byte	.LFB18
 2424 009c 2C000000 		.4byte	.LFE18-.LFB18
 2425 00a0 00000000 		.4byte	.LFB19
 2426 00a4 14000000 		.4byte	.LFE19-.LFB19
 2427 00a8 00000000 		.4byte	.LFB20
 2428 00ac 34000000 		.4byte	.LFE20-.LFB20
 2429 00b0 00000000 		.4byte	.LFB21
 2430 00b4 54000000 		.4byte	.LFE21-.LFB21
 2431 00b8 00000000 		.4byte	.LFB22
 2432 00bc 58000000 		.4byte	.LFE22-.LFB22
 2433 00c0 00000000 		.4byte	.LFB23
 2434 00c4 34000000 		.4byte	.LFE23-.LFB23
 2435 00c8 00000000 		.4byte	.LFB24
 2436 00cc 48000000 		.4byte	.LFE24-.LFB24
 2437 00d0 00000000 		.4byte	.LFB25
 2438 00d4 44000000 		.4byte	.LFE25-.LFB25
 2439 00d8 00000000 		.4byte	.LFB26
 2440 00dc B8000000 		.4byte	.LFE26-.LFB26
 2441 00e0 00000000 		.4byte	.LFB27
 2442 00e4 12000000 		.4byte	.LFE27-.LFB27
 2443 00e8 00000000 		.4byte	0
 2444 00ec 00000000 		.4byte	0
 2445              		.section	.debug_ranges,"",%progbits
 2446              	.Ldebug_ranges0:
 2447 0000 00000000 		.4byte	.LFB1
 2448 0004 24000000 		.4byte	.LFE1
 2449 0008 00000000 		.4byte	.LFB2
 2450 000c 3C000000 		.4byte	.LFE2
 2451 0010 00000000 		.4byte	.LFB3
 2452 0014 64000000 		.4byte	.LFE3
 2453 0018 00000000 		.4byte	.LFB4
 2454 001c 60000000 		.4byte	.LFE4
 2455 0020 00000000 		.4byte	.LFB5
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 72


 2456 0024 0C000000 		.4byte	.LFE5
 2457 0028 00000000 		.4byte	.LFB6
 2458 002c 12000000 		.4byte	.LFE6
 2459 0030 00000000 		.4byte	.LFB7
 2460 0034 20000000 		.4byte	.LFE7
 2461 0038 00000000 		.4byte	.LFB8
 2462 003c 20000000 		.4byte	.LFE8
 2463 0040 00000000 		.4byte	.LFB9
 2464 0044 24000000 		.4byte	.LFE9
 2465 0048 00000000 		.4byte	.LFB10
 2466 004c 4C000000 		.4byte	.LFE10
 2467 0050 00000000 		.4byte	.LFB11
 2468 0054 22000000 		.4byte	.LFE11
 2469 0058 00000000 		.4byte	.LFB12
 2470 005c 30000000 		.4byte	.LFE12
 2471 0060 00000000 		.4byte	.LFB13
 2472 0064 44000000 		.4byte	.LFE13
 2473 0068 00000000 		.4byte	.LFB14
 2474 006c 12000000 		.4byte	.LFE14
 2475 0070 00000000 		.4byte	.LFB15
 2476 0074 20000000 		.4byte	.LFE15
 2477 0078 00000000 		.4byte	.LFB16
 2478 007c 20000000 		.4byte	.LFE16
 2479 0080 00000000 		.4byte	.LFB17
 2480 0084 20000000 		.4byte	.LFE17
 2481 0088 00000000 		.4byte	.LFB18
 2482 008c 2C000000 		.4byte	.LFE18
 2483 0090 00000000 		.4byte	.LFB19
 2484 0094 14000000 		.4byte	.LFE19
 2485 0098 00000000 		.4byte	.LFB20
 2486 009c 34000000 		.4byte	.LFE20
 2487 00a0 00000000 		.4byte	.LFB21
 2488 00a4 54000000 		.4byte	.LFE21
 2489 00a8 00000000 		.4byte	.LFB22
 2490 00ac 58000000 		.4byte	.LFE22
 2491 00b0 00000000 		.4byte	.LFB23
 2492 00b4 34000000 		.4byte	.LFE23
 2493 00b8 00000000 		.4byte	.LFB24
 2494 00bc 48000000 		.4byte	.LFE24
 2495 00c0 00000000 		.4byte	.LFB25
 2496 00c4 44000000 		.4byte	.LFE25
 2497 00c8 00000000 		.4byte	.LFB26
 2498 00cc B8000000 		.4byte	.LFE26
 2499 00d0 00000000 		.4byte	.LFB27
 2500 00d4 12000000 		.4byte	.LFE27
 2501 00d8 00000000 		.4byte	0
 2502 00dc 00000000 		.4byte	0
 2503              		.section	.debug_line,"",%progbits
 2504              	.Ldebug_line0:
 2505 0000 E8020000 		.section	.debug_str,"MS",%progbits,1
 2505      02004300 
 2505      00000201 
 2505      FB0E0D00 
 2505      01010101 
 2506              	.LASF10:
 2507 0000 75696E74 		.ascii	"uint16\000"
 2507      313600
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 73


 2508              	.LASF44:
 2509 0007 74784461 		.ascii	"txDataByte\000"
 2509      74614279 
 2509      746500
 2510              	.LASF62:
 2511 0012 433A5C55 		.ascii	"C:\\Users\\Matty\\Documents\\PSoC Creator\\RF_Switc"
 2511      73657273 
 2511      5C4D6174 
 2511      74795C44 
 2511      6F63756D 
 2512 0040 685F4D61 		.ascii	"h_Matrix\\RF_Switch_Matrix.cydsn\000"
 2512      74726978 
 2512      5C52465F 
 2512      53776974 
 2512      63685F4D 
 2513              	.LASF48:
 2514 0060 73747269 		.ascii	"string\000"
 2514      6E6700
 2515              	.LASF7:
 2516 0067 6C6F6E67 		.ascii	"long long unsigned int\000"
 2516      206C6F6E 
 2516      6720756E 
 2516      7369676E 
 2516      65642069 
 2517              	.LASF17:
 2518 007e 55415254 		.ascii	"UART_Start\000"
 2518      5F537461 
 2518      727400
 2519              	.LASF42:
 2520 0089 55415254 		.ascii	"UART_SetTxInterruptMode\000"
 2520      5F536574 
 2520      5478496E 
 2520      74657272 
 2520      7570744D 
 2521              	.LASF6:
 2522 00a1 6C6F6E67 		.ascii	"long long int\000"
 2522      206C6F6E 
 2522      6720696E 
 2522      7400
 2523              	.LASF0:
 2524 00af 7369676E 		.ascii	"signed char\000"
 2524      65642063 
 2524      68617200 
 2525              	.LASF58:
 2526 00bb 74785065 		.ascii	"txPeriod\000"
 2526      72696F64 
 2526      00
 2527              	.LASF4:
 2528 00c4 6C6F6E67 		.ascii	"long int\000"
 2528      20696E74 
 2528      00
 2529              	.LASF46:
 2530 00cd 55415254 		.ascii	"UART_PutChar\000"
 2530      5F507574 
 2530      43686172 
 2530      00
 2531              	.LASF27:
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 74


 2532 00da 55415254 		.ascii	"UART_ReadRxData\000"
 2532      5F526561 
 2532      64527844 
 2532      61746100 
 2533              	.LASF9:
 2534 00ea 75696E74 		.ascii	"uint8\000"
 2534      3800
 2535              	.LASF32:
 2536 00f0 55415254 		.ascii	"UART_ReadControlRegister\000"
 2536      5F526561 
 2536      64436F6E 
 2536      74726F6C 
 2536      52656769 
 2537              	.LASF12:
 2538 0109 646F7562 		.ascii	"double\000"
 2538      6C6500
 2539              	.LASF38:
 2540 0110 61646472 		.ascii	"addressMode\000"
 2540      6573734D 
 2540      6F646500 
 2541              	.LASF24:
 2542 011c 636F6E74 		.ascii	"control\000"
 2542      726F6C00 
 2543              	.LASF18:
 2544 0124 55415254 		.ascii	"UART_Init\000"
 2544      5F496E69 
 2544      7400
 2545              	.LASF56:
 2546 012e 7265744D 		.ascii	"retMode\000"
 2546      6F646500 
 2547              	.LASF33:
 2548 0136 55415254 		.ascii	"UART_GetByte\000"
 2548      5F476574 
 2548      42797465 
 2548      00
 2549              	.LASF8:
 2550 0143 756E7369 		.ascii	"unsigned int\000"
 2550      676E6564 
 2550      20696E74 
 2550      00
 2551              	.LASF54:
 2552 0150 55415254 		.ascii	"UART_ClearTxBuffer\000"
 2552      5F436C65 
 2552      61725478 
 2552      42756666 
 2552      657200
 2553              	.LASF52:
 2554 0163 55415254 		.ascii	"UART_PutCRLF\000"
 2554      5F507574 
 2554      43524C46 
 2554      00
 2555              	.LASF5:
 2556 0170 6C6F6E67 		.ascii	"long unsigned int\000"
 2556      20756E73 
 2556      69676E65 
 2556      6420696E 
 2556      7400
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 75


 2557              	.LASF50:
 2558 0182 55415254 		.ascii	"UART_PutArray\000"
 2558      5F507574 
 2558      41727261 
 2558      7900
 2559              	.LASF35:
 2560 0190 73697A65 		.ascii	"size\000"
 2560      00
 2561              	.LASF3:
 2562 0195 73686F72 		.ascii	"short unsigned int\000"
 2562      7420756E 
 2562      7369676E 
 2562      65642069 
 2562      6E7400
 2563              	.LASF49:
 2564 01a8 62756649 		.ascii	"bufIndex\000"
 2564      6E646578 
 2564      00
 2565              	.LASF25:
 2566 01b1 696E7453 		.ascii	"intSrc\000"
 2566      726300
 2567              	.LASF59:
 2568 01b8 55415254 		.ascii	"UART_SetTxAddressMode\000"
 2568      5F536574 
 2568      54784164 
 2568      64726573 
 2568      734D6F64 
 2569              	.LASF61:
 2570 01ce 2E5C4765 		.ascii	".\\Generated_Source\\PSoC4\\UART.c\000"
 2570      6E657261 
 2570      7465645F 
 2570      536F7572 
 2570      63655C50 
 2571              	.LASF45:
 2572 01ee 55415254 		.ascii	"UART_ReadTxStatus\000"
 2572      5F526561 
 2572      64547853 
 2572      74617475 
 2572      7300
 2573              	.LASF57:
 2574 0200 746D7053 		.ascii	"tmpStat\000"
 2574      74617400 
 2575              	.LASF16:
 2576 0208 73697A65 		.ascii	"sizetype\000"
 2576      74797065 
 2576      00
 2577              	.LASF40:
 2578 0211 61646472 		.ascii	"address\000"
 2578      65737300 
 2579              	.LASF39:
 2580 0219 55415254 		.ascii	"UART_SetRxAddress1\000"
 2580      5F536574 
 2580      52784164 
 2580      64726573 
 2580      733100
 2581              	.LASF41:
 2582 022c 55415254 		.ascii	"UART_SetRxAddress2\000"
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 76


 2582      5F536574 
 2582      52784164 
 2582      64726573 
 2582      733200
 2583              	.LASF31:
 2584 023f 72785374 		.ascii	"rxStatus\000"
 2584      61747573 
 2584      00
 2585              	.LASF11:
 2586 0248 666C6F61 		.ascii	"float\000"
 2586      7400
 2587              	.LASF60:
 2588 024e 474E5520 		.ascii	"GNU C 4.8.4 20140526 (release) [ARM/embedded-4_8-br"
 2588      4320342E 
 2588      382E3420 
 2588      32303134 
 2588      30353236 
 2589 0281 616E6368 		.ascii	"anch revision 211358] -mcpu=cortex-m0 -mthumb -g -O"
 2589      20726576 
 2589      6973696F 
 2589      6E203231 
 2589      31333538 
 2590 02b4 30202D66 		.ascii	"0 -ffunction-sections\000"
 2590      66756E63 
 2590      74696F6E 
 2590      2D736563 
 2590      74696F6E 
 2591              	.LASF53:
 2592 02ca 55415254 		.ascii	"UART_GetTxBufferSize\000"
 2592      5F476574 
 2592      54784275 
 2592      66666572 
 2592      53697A65 
 2593              	.LASF15:
 2594 02df 72656738 		.ascii	"reg8\000"
 2594      00
 2595              	.LASF37:
 2596 02e4 55415254 		.ascii	"UART_SetRxAddressMode\000"
 2596      5F536574 
 2596      52784164 
 2596      64726573 
 2596      734D6F64 
 2597              	.LASF1:
 2598 02fa 756E7369 		.ascii	"unsigned char\000"
 2598      676E6564 
 2598      20636861 
 2598      7200
 2599              	.LASF43:
 2600 0308 55415254 		.ascii	"UART_WriteTxData\000"
 2600      5F577269 
 2600      74655478 
 2600      44617461 
 2600      00
 2601              	.LASF2:
 2602 0319 73686F72 		.ascii	"short int\000"
 2602      7420696E 
 2602      7400
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 77


 2603              	.LASF55:
 2604 0323 55415254 		.ascii	"UART_SendBreak\000"
 2604      5F53656E 
 2604      64427265 
 2604      616B00
 2605              	.LASF51:
 2606 0332 62797465 		.ascii	"byteCount\000"
 2606      436F756E 
 2606      7400
 2607              	.LASF26:
 2608 033c 72784461 		.ascii	"rxData\000"
 2608      746100
 2609              	.LASF19:
 2610 0343 55415254 		.ascii	"UART_Enable\000"
 2610      5F456E61 
 2610      626C6500 
 2611              	.LASF28:
 2612 034f 55415254 		.ascii	"UART_ReadRxStatus\000"
 2612      5F526561 
 2612      64527853 
 2612      74617475 
 2612      7300
 2613              	.LASF14:
 2614 0361 63686172 		.ascii	"char\000"
 2614      00
 2615              	.LASF13:
 2616 0366 63686172 		.ascii	"char8\000"
 2616      3800
 2617              	.LASF23:
 2618 036c 55415254 		.ascii	"UART_SetRxInterruptMode\000"
 2618      5F536574 
 2618      5278496E 
 2618      74657272 
 2618      7570744D 
 2619              	.LASF30:
 2620 0384 55415254 		.ascii	"UART_GetChar\000"
 2620      5F476574 
 2620      43686172 
 2620      00
 2621              	.LASF21:
 2622 0391 656E6162 		.ascii	"enableInterrupts\000"
 2622      6C65496E 
 2622      74657272 
 2622      75707473 
 2622      00
 2623              	.LASF63:
 2624 03a2 55415254 		.ascii	"UART_initVar\000"
 2624      5F696E69 
 2624      74566172 
 2624      00
 2625              	.LASF34:
 2626 03af 55415254 		.ascii	"UART_GetRxBufferSize\000"
 2626      5F476574 
 2626      52784275 
 2626      66666572 
 2626      53697A65 
 2627              	.LASF29:
ARM GAS  C:\Users\Matty\AppData\Local\Temp\ccEFBCvr.s 			page 78


 2628 03c4 73746174 		.ascii	"status\000"
 2628      757300
 2629              	.LASF20:
 2630 03cb 55415254 		.ascii	"UART_Stop\000"
 2630      5F53746F 
 2630      7000
 2631              	.LASF47:
 2632 03d5 55415254 		.ascii	"UART_PutString\000"
 2632      5F507574 
 2632      53747269 
 2632      6E6700
 2633              	.LASF22:
 2634 03e4 55415254 		.ascii	"UART_WriteControlRegister\000"
 2634      5F577269 
 2634      7465436F 
 2634      6E74726F 
 2634      6C526567 
 2635              	.LASF36:
 2636 03fe 55415254 		.ascii	"UART_ClearRxBuffer\000"
 2636      5F436C65 
 2636      61725278 
 2636      42756666 
 2636      657200
 2637              		.ident	"GCC: (GNU Tools for ARM Embedded Processors) 4.8.4 20140526 (release) [ARM/embedded-4_8-br
