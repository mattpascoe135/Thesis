<?xml version="1.0" encoding="utf-8"?>
<device schemaVersion="1.0" xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" xs:noNamespaceSchemaLocation="CMSIS-SVD_Schema_1_0.xsd">
  <name>CY8C4247AZI_M485</name>
  <version>0.1</version>
  <description>PSoC 4200M</description>
  <addressUnitBits>8</addressUnitBits>
  <width>32</width>
  <peripherals>
    <peripheral>
      <name>DMAC</name>
      <description>DMAC Registers</description>
      <baseAddress>0x40101000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x0</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>DMAC_CTL</name>
          <description>DMA controller control register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Global DMAC enable</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>DMA controller is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>DMA controller is enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_STATUS</name>
          <description>DMA controller status register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Specifies the index of the currently active data transfer. This value increases from '0' to the DATA_NR field specified of the currently active descriptor control word.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CH_ADDR</name>
              <description>Specifies the channel number of the currently active channel. For example, if channel 7 is active, DMAC_STATUS.ACTIVE is '1' and STATUS.CH_ADDR is '7'.</description>
              <lsb>16</lsb>
              <msb>20</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>STATE</name>
              <description>State of the data transfer engine.</description>
              <lsb>24</lsb>
              <msb>26</msb>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IDLE</name>
                  <description>Idle state when the DMA is not active.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LOAD_DESCR</name>
                  <description>The DMA is loading the descriptor to the DMA transfer engine.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LOAD_SRC</name>
                  <description>The DMA is getting the value from the source location.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>STORE_DST</name>
                  <description>The DMA is storing the value at the destination location.</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>STORE_DESCR</name>
                  <description>The DMA is updating the descriptors after completion of transfer.</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WAIT_TRIG_DEACT</name>
                  <description>The DMA is waiting for the level sensitive trigger to deactivate.</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>STORE_ERROR</name>
                  <description>There was an error during the transaction and the DMA is writing the error code to the channel status register.</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Specifies the priority of the currently active channel.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Specifies whether the PING descriptor ('0') or PONG descriptor ('1') of the channel is currently in use.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ACTIVE</name>
              <description>Specifies if there is a currently active (pending) channel in the data transfer engine.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IDLE</name>
                  <description>No currently active channel.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACTIVE</name>
                  <description>Currently active channel.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_STATUS_SRC_ADDR</name>
          <description>Source address currently being used by the DMA controller</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>The source address currently being used by the DMA transfer engine. This field is provided for debug purposes. Note while reading the DMAC_STATUS, DMAC_STATUS_SRC_ADDR and DMAC_STATUS_DST_ADDR registers, the transfer engine may have advanced after one or more of these reads. Meaning the register values may not be related to each other.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_STATUS_DST_ADDR</name>
          <description>Destination address currently being used by the DMA controller</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>The destination address currently being used by the DMA transfer engine. This field is provided for debug purposes. Note while reading the DMAC_STATUS, DMAC_STATUS_SRC_ADDR and DMAC_STATUS_DST_ADDR registers, the transfer engine may have advanced after one or more of these reads. Meaning the register values may not be related to each other.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_STATUS_CH_ACT</name>
          <description>Channel activation status</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CH</name>
              <description>Channel activation status. Bit i is associated to channel i. Software reads this field to get information on all actively pending channels (either in pending or in the data transfer engine).</description>
              <lsb>0</lsb>
              <msb>7</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL0</name>
          <description>DMA channel 0 control register</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL1</name>
          <description>DMA channel 1 control register</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL2</name>
          <description>DMA channel 2 control register</description>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL3</name>
          <description>DMA channel 3 control register</description>
          <addressOffset>0x8C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL4</name>
          <description>DMA channel 4 control register</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL5</name>
          <description>DMA channel 5 control register</description>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL6</name>
          <description>DMA channel 6 control register</description>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL7</name>
          <description>DMA channel 7 control register</description>
          <addressOffset>0x9C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_INTR</name>
          <description>Interrupt register</description>
          <addressOffset>0x7F0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CH</name>
              <description>Set to '1', when event is detected. Write INTR field with '1', to clear bit. Write INTR_SET field with '1', to set bit.</description>
              <lsb>0</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_INTR_SET</name>
          <description>Interrupt set register</description>
          <addressOffset>0x7F4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CH</name>
              <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
              <lsb>0</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_INTR_MASK</name>
          <description>Interrupt mask register</description>
          <addressOffset>0x7F8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CH</name>
              <description>Mask for corresponding field in INTR register.</description>
              <lsb>0</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_INTR_MASKED</name>
          <description>Interrupt masked register</description>
          <addressOffset>0x7FC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CH</name>
              <description>Bitwise AND between the interrupt reguest (INTR) and mask (INTR_MASK) registers.</description>
              <lsb>0</lsb>
              <msb>7</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR0_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 0</description>
          <addressOffset>0x800</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR0_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 0</description>
          <addressOffset>0x804</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR0_PING_CTL</name>
          <description>Descriptor 0 control register for channel 0</description>
          <addressOffset>0x808</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR0_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 0</description>
          <addressOffset>0x80C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR0_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 0</description>
          <addressOffset>0x810</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR0_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 0</description>
          <addressOffset>0x814</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR0_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 0</description>
          <addressOffset>0x818</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR0_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 0</description>
          <addressOffset>0x81C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR1_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 1</description>
          <addressOffset>0x820</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR1_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 1</description>
          <addressOffset>0x824</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR1_PING_CTL</name>
          <description>Descriptor 0 control register for channel 1</description>
          <addressOffset>0x828</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR1_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 1</description>
          <addressOffset>0x82C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR1_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 1</description>
          <addressOffset>0x830</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR1_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 1</description>
          <addressOffset>0x834</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR1_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 1</description>
          <addressOffset>0x838</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR1_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 1</description>
          <addressOffset>0x83C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR2_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 2</description>
          <addressOffset>0x840</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR2_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 2</description>
          <addressOffset>0x844</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR2_PING_CTL</name>
          <description>Descriptor 0 control register for channel 2</description>
          <addressOffset>0x848</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR2_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 2</description>
          <addressOffset>0x84C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR2_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 2</description>
          <addressOffset>0x850</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR2_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 2</description>
          <addressOffset>0x854</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR2_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 2</description>
          <addressOffset>0x858</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR2_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 2</description>
          <addressOffset>0x85C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR3_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 3</description>
          <addressOffset>0x860</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR3_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 3</description>
          <addressOffset>0x864</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR3_PING_CTL</name>
          <description>Descriptor 0 control register for channel 3</description>
          <addressOffset>0x868</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR3_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 3</description>
          <addressOffset>0x86C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR3_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 3</description>
          <addressOffset>0x870</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR3_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 3</description>
          <addressOffset>0x874</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR3_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 3</description>
          <addressOffset>0x878</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR3_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 3</description>
          <addressOffset>0x87C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR4_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 4</description>
          <addressOffset>0x880</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR4_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 4</description>
          <addressOffset>0x884</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR4_PING_CTL</name>
          <description>Descriptor 0 control register for channel 4</description>
          <addressOffset>0x888</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR4_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 4</description>
          <addressOffset>0x88C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR4_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 4</description>
          <addressOffset>0x890</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR4_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 4</description>
          <addressOffset>0x894</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR4_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 4</description>
          <addressOffset>0x898</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR4_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 4</description>
          <addressOffset>0x89C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR5_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 5</description>
          <addressOffset>0x8A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR5_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 5</description>
          <addressOffset>0x8A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR5_PING_CTL</name>
          <description>Descriptor 0 control register for channel 5</description>
          <addressOffset>0x8A8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR5_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 5</description>
          <addressOffset>0x8AC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR5_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 5</description>
          <addressOffset>0x8B0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR5_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 5</description>
          <addressOffset>0x8B4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR5_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 5</description>
          <addressOffset>0x8B8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR5_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 5</description>
          <addressOffset>0x8BC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR6_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 6</description>
          <addressOffset>0x8C0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR6_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 6</description>
          <addressOffset>0x8C4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR6_PING_CTL</name>
          <description>Descriptor 0 control register for channel 6</description>
          <addressOffset>0x8C8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR6_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 6</description>
          <addressOffset>0x8CC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR6_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 6</description>
          <addressOffset>0x8D0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR6_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 6</description>
          <addressOffset>0x8D4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR6_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 6</description>
          <addressOffset>0x8D8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR6_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 6</description>
          <addressOffset>0x8DC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR7_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 7</description>
          <addressOffset>0x8E0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR7_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 7</description>
          <addressOffset>0x8E4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR7_PING_CTL</name>
          <description>Descriptor 0 control register for channel 7</description>
          <addressOffset>0x8E8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR7_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 7</description>
          <addressOffset>0x8EC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR7_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 7</description>
          <addressOffset>0x8F0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR7_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 7</description>
          <addressOffset>0x8F4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR7_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 7</description>
          <addressOffset>0x8F8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR7_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 7</description>
          <addressOffset>0x8FC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>UART</name>
      <description>UART</description>
      <baseAddress>0x0</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x0</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>RX_UART_RX_ADDRESS1</name>
          <description>RX Address1 Register</description>
          <addressOffset>0x400F0021</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
        </register>
        <register>
          <name>RX_UART_RX_ADDRESS2</name>
          <description>RX Address2 Register</description>
          <addressOffset>0x400F0031</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
        </register>
        <register>
          <name>RX_UART_RX_DATA</name>
          <description>RX Data Register</description>
          <addressOffset>0x400F0041</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
        </register>
        <register>
          <name>TX_UART_TX_DATA</name>
          <description>TX Data Register</description>
          <addressOffset>0x400F0042</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
        </register>
        <register>
          <name>RX_UART_RX_STATUS</name>
          <description>RX status register</description>
          <addressOffset>0x400F0060</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>UART_RX_STS_MRKSPC</name>
              <description>No description available</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_RX_STS_BREAK</name>
              <description>No description available</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_RX_STS_PAR_ERROR</name>
              <description>No description available</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_RX_STS_STOP_ERROR</name>
              <description>No description available</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_RX_STS_OVERRUN</name>
              <description>No description available</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_RX_STS_FIFO_NOTEMPTY</name>
              <description>No description available</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_RX_STS_ADDR_MATCH</name>
              <description>No description available</description>
              <lsb>6</lsb>
              <msb>6</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_UART_TX_STATUS</name>
          <description>TX status register</description>
          <addressOffset>0x400F0062</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>UART_TX_STS_COMPLETE</name>
              <description>No description available</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_TX_STS_FIFO_EMPTY</name>
              <description>No description available</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_TX_STS_FIFO_FULL</name>
              <description>No description available</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_TX_STS_FIFO_NOT_FULL</name>
              <description>No description available</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>OutputReg</name>
      <description>No description available</description>
      <baseAddress>0x400F0070</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x0</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>OutputReg_CONTROL_REG</name>
          <description>No description available</description>
          <addressOffset>0x0</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
        </register>
      </registers>
    </peripheral>
  </peripherals>
</device>